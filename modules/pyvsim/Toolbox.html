

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pyvsim.Toolbox &mdash; pyvsim 1.0 documentation</title>
    
    <link rel="stylesheet" href="../../static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../static/jquery.js"></script>
    <script type="text/javascript" src="../../static/underscore.js"></script>
    <script type="text/javascript" src="../../static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="pyvsim 1.0 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">pyvsim 1.0 documentation</a> &raquo;</li>
          <li><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for pyvsim.Toolbox</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">.. module :: Toolbox</span>
<span class="sd">    :platform: Unix, Windows</span>
<span class="sd">    :synopsis: Equipment model</span>
<span class="sd">    </span>
<span class="sd">This module packs models for equipment usually employed in PIV measurements.</span>

<span class="sd">    </span>
<span class="sd">.. moduleauthor :: Ricardo Entz &lt;maiko at thebigheads.net&gt;</span>

<span class="sd">.. license::</span>
<span class="sd">    PyVSim v.1</span>
<span class="sd">    Copyright 2013 Ricardo Entz</span>
<span class="sd">    </span>
<span class="sd">    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="sd">    you may not use this file except in compliance with the License.</span>
<span class="sd">    You may obtain a copy of the License at</span>
<span class="sd">    </span>
<span class="sd">        http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="sd">    </span>
<span class="sd">    Unless required by applicable law or agreed to in writing, software</span>
<span class="sd">    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="sd">    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="sd">    See the License for the specific language governing permissions and</span>
<span class="sd">    limitations under the License.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span> 
<span class="kn">import</span> <span class="nn">Utils</span>
<span class="kn">import</span> <span class="nn">Primitives</span>
<span class="kn">import</span> <span class="nn">MieUtils</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">erf</span><span class="p">,</span> <span class="n">gammainc</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">RectBivariateSpline</span><span class="p">,</span> <span class="n">interp1d</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">gdal</span>
<span class="kn">import</span> <span class="nn">Core</span>

<span class="n">MEMSIZE</span>     <span class="o">=</span> <span class="mf">1e6</span>
<span class="n">MEM_SAFETY</span>  <span class="o">=</span> <span class="mi">8</span>
<span class="n">STD_PARAM</span>   <span class="o">=</span> <span class="mf">0.040</span>
<span class="n">GLOBAL_TOL</span>  <span class="o">=</span> <span class="mf">1e-8</span>
<span class="n">GLOBAL_NDIM</span> <span class="o">=</span> <span class="mi">3</span>

<div class="viewcode-block" id="Mirror"><a class="viewcode-back" href="../../Mirror.html#pyvsim.Toolbox.Mirror">[docs]</a><span class="k">class</span> <span class="nc">Mirror</span><span class="p">(</span><span class="n">Primitives</span><span class="o">.</span><span class="n">Plane</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class initializes a 1x1m mirror, which can be resized by the</span>
<span class="sd">    methods::</span>
<span class="sd">    </span>
<span class="sd">    * :meth:`~Primitives.Plane.dimension` (preferred); or</span>
<span class="sd">    * :meth:`~Primitives.Plane.length`</span>
<span class="sd">    * :meth:`~Primitives.Plane.heigth`  </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">Primitives</span><span class="o">.</span><span class="n">Plane</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span>               <span class="o">=</span> <span class="s">&#39;Mirror &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfaceProperty</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MIRROR</span>
        </div>
<div class="viewcode-block" id="Dump"><a class="viewcode-back" href="../../Dump.html#pyvsim.Toolbox.Dump">[docs]</a><span class="k">class</span> <span class="nc">Dump</span><span class="p">(</span><span class="n">Primitives</span><span class="o">.</span><span class="n">Plane</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class initializes a 1x1m beam dump, that will stop any ray that</span>
<span class="sd">    arrives at it.</span>
<span class="sd">    </span>
<span class="sd">    * :meth:`~Primitives.Plane.dimension` (preferred); or</span>
<span class="sd">    * :meth:`~Primitives.Plane.length`</span>
<span class="sd">    * :meth:`~Primitives.Plane.heigth`  </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">Primitives</span><span class="o">.</span><span class="n">Plane</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span>               <span class="o">=</span> <span class="s">&#39;Dump &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfaceProperty</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">DUMP</span>
</div>
<div class="viewcode-block" id="Sensor"><a class="viewcode-back" href="../../Sensor.html#pyvsim.Toolbox.Sensor">[docs]</a><span class="k">class</span> <span class="nc">Sensor</span><span class="p">(</span><span class="n">Primitives</span><span class="o">.</span><span class="n">Plane</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class describes a sensor. It is responsible for determining the size</span>
<span class="sd">    of the camera field of view and also for recording particles.</span>
<span class="sd">    </span>
<span class="sd">    The particle recording behavior is similar to the one described by Lecordier</span>
<span class="sd">    and Westerweel in their `synthetic image generator </span>
<span class="sd">    &lt;http://link.springer.com/chapter/10.1007%2F978-3-642-18795-7_11&gt;`_ .</span>
<span class="sd">    </span>
<span class="sd">    Some features can be easily implemented such as:</span>
<span class="sd">    </span>
<span class="sd">    * Quantum efficiency as a function of wavelength (as the recording function</span>
<span class="sd">        receives the wavelength as a parameter)</span>
<span class="sd">    * Light field measurement (the &quot;virtualData&quot; field can be used to store </span>
<span class="sd">        more data)</span>
<span class="sd">        </span>
<span class="sd">    But were not implemented until now.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        --|----------------------------------&gt; </span>
<span class="sd">          |                            |     z</span>
<span class="sd">          |                            |</span>
<span class="sd">          |                            | </span>
<span class="sd">          |                            |</span>
<span class="sd">          |                            |      </span>
<span class="sd">          |                            |      </span>
<span class="sd">          |                            | </span>
<span class="sd">          |                            |</span>
<span class="sd">          v ___________________________| </span>
<span class="sd">           y</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Primitives</span><span class="o">.</span><span class="n">Plane</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span>                   <span class="o">=</span> <span class="s">&#39;Sensor &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">)</span>
        <span class="c"># self.heigth = 0.024                   x      y        z</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>              <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span>  <span class="mf">0.0090</span><span class="p">,</span>  <span class="mf">0.0122</span><span class="p">])</span>
<span class="c">#        self.dimension              = np.array([0,  0.024,  0.036])</span>

        
        <span class="c">#                                      # ROW         # COLUMN</span>
        <span class="c">#                                      #0.0089         0.0118</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span>             <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1200</span><span class="p">,</span>         <span class="mi">1600</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pixelSize</span>              <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">7.40</span><span class="p">,</span>         <span class="mf">7.40</span><span class="p">])</span><span class="o">*</span><span class="mf">1e-6</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fillRatio</span>              <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.75</span><span class="p">,</span>         <span class="mf">0.75</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fullWellCapacity</span>       <span class="o">=</span> <span class="mf">40e3</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quantumEfficiency</span>      <span class="o">=</span> <span class="mf">0.5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gain</span>                   <span class="o">=</span> <span class="mf">2.1</span> <span class="c">#photons / count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bitDepth</span>               <span class="o">=</span> <span class="mi">14</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">backgroundMeanLevel</span>    <span class="o">=</span> <span class="mi">244</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">backgroundNoiseStd</span>     <span class="o">=</span> <span class="mi">50</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rawData</span>                <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">saturationData</span>         <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deadPixels</span>             <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hotPixels</span>              <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">virtualData</span>            <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">color</span>                  <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        
   
<div class="viewcode-block" id="Sensor.display"><a class="viewcode-back" href="../../Sensor.html#pyvsim.Toolbox.Sensor.display">[docs]</a>    <span class="k">def</span> <span class="nf">display</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">colormap</span><span class="o">=</span><span class="s">&#39;jet&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function displays what is currently recorded in the camera sensor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">facecolor</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="c">#imgplot = plt.imshow(self.readSensor()/(-1+2**self.bitDepth))</span>
        <span class="n">imgplot</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">readSensor</span><span class="p">())</span>
        <span class="n">imgplot</span><span class="o">.</span><span class="n">set_cmap</span><span class="p">(</span><span class="n">colormap</span><span class="p">)</span>
        <span class="n">imgplot</span><span class="o">.</span><span class="n">set_interpolation</span><span class="p">(</span><span class="s">&#39;none&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>    
    </div>
<div class="viewcode-block" id="Sensor.createDeadPixels"><a class="viewcode-back" href="../../Sensor.html#pyvsim.Toolbox.Sensor.createDeadPixels">[docs]</a>    <span class="k">def</span> <span class="nf">createDeadPixels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">probability</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a dead/hot pixel mapping for the sensor reading simulation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">deathMap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deadPixels</span> <span class="o">=</span> <span class="n">deathMap</span> <span class="o">&gt;</span> <span class="n">probability</span><span class="o">*</span><span class="mf">0.5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hotPixels</span>  <span class="o">=</span> <span class="n">deathMap</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">probability</span><span class="o">*</span><span class="mf">0.5</span>
        </div>
<div class="viewcode-block" id="Sensor.clear"><a class="viewcode-back" href="../../Sensor.html#pyvsim.Toolbox.Sensor.clear">[docs]</a>    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes sensor with gaussian noise, the distribution parameters are</span>
<span class="sd">        given by:</span>
<span class="sd">        </span>
<span class="sd">        * backgroundMeanLevel - the mean value</span>
<span class="sd">        * backgroundNoiseVar - the variance of the distribution</span>
<span class="sd">        </span>
<span class="sd">        To handle negative values, only the absolute value is taken into account</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rawData</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">backgroundMeanLevel</span> <span class="o">+</span> 
                              <span class="bp">self</span><span class="o">.</span><span class="n">backgroundNoiseStd</span> <span class="o">*</span> 
                              <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        </div>
<div class="viewcode-block" id="Sensor.readSensor"><a class="viewcode-back" href="../../Sensor.html#pyvsim.Toolbox.Sensor.readSensor">[docs]</a>    <span class="k">def</span> <span class="nf">readSensor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the sensor reading in counts, creating quantization noise and</span>
<span class="sd">        saturating the signal where appropriate. This also simulates dead pixels,</span>
<span class="sd">        if there is a dead pixel mapping</span>
<span class="sd">        </span>
<span class="sd">        The readout noise, however, should be included in the background noise</span>
<span class="sd">        property of the class</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rawData</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">fullWellCapacity</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">deadPixels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span> 
            <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">deadPixels</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">hotPixels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">saturationData</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c"># Corrects if any place is less than zero (may happen due to noise)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">-</span> <span class="n">s</span><span class="o">*</span><span class="p">(</span><span class="n">s</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c"># Corrects saturations</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">-</span> <span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">s</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c"># Return result as counts:</span>
        <span class="k">return</span>  <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">s</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">bitDepth</span><span class="p">))</span>
    </div>
<div class="viewcode-block" id="Sensor.save"><a class="viewcode-back" href="../../Sensor.html#pyvsim.Toolbox.Sensor.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes the sensor data in a 16-bit TIFF file (which is compatible</span>
<span class="sd">        with some mainstream PIV software)</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : string</span>
<span class="sd">            The file name and path (including the extension)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">readSensor</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">)</span>
        <span class="n">dr</span> <span class="o">=</span> <span class="n">gdal</span><span class="o">.</span><span class="n">GetDriverByName</span><span class="p">(</span><span class="s">&quot;GTiff&quot;</span><span class="p">)</span>
        <span class="n">outDs</span> <span class="o">=</span> <span class="n">dr</span><span class="o">.</span><span class="n">Create</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> 
                          <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> 
                          <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> 
                          <span class="mi">1</span><span class="p">,</span> 
                          <span class="n">gdal</span><span class="o">.</span><span class="n">GDT_Int16</span><span class="p">)</span> 
        <span class="n">outBand</span> <span class="o">=</span> <span class="n">outDs</span><span class="o">.</span><span class="n">GetRasterBand</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">outBand</span><span class="o">.</span><span class="n">WriteArray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">outBand</span><span class="o">.</span><span class="n">FlushCache</span><span class="p">()</span>
        <span class="n">outBand</span><span class="o">.</span><span class="n">SetNoDataValue</span><span class="p">(</span><span class="o">-</span><span class="mi">99</span><span class="p">)</span>
        <span class="c"># This seems to be the wonderful way of gdal to close files, sorry</span>
        <span class="n">dr</span>      <span class="o">=</span> <span class="bp">None</span>
        <span class="n">outDs</span>   <span class="o">=</span> <span class="bp">None</span>
        <span class="n">outBand</span> <span class="o">=</span> <span class="bp">None</span>
    </div>
<div class="viewcode-block" id="Sensor.parametricToSensor"><a class="viewcode-back" href="../../Sensor.html#pyvsim.Toolbox.Sensor.parametricToSensor">[docs]</a>    <span class="k">def</span> <span class="nf">parametricToSensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param_coords</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        From the parametric coordinates :math:`\\\overline{U,V}`,</span>
<span class="sd">        which range is :math:`[-1..1]`, calculates the sensor coordinates in</span>
<span class="sd">        meters, so the algorithm is basically multiplying by the sensor size.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        param_coords : numpy.ndarray (N,2)</span>
<span class="sd">            The parametric coordinates in the range -1..1. </span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sensor_coords : numpy.ndarray (N,2)</span>
<span class="sd">            The sensor coordinates in meters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dim_uv</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">[</span><span class="mi">1</span><span class="p">:][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">uvlist</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&quot;ij,j-&gt;ij&quot;</span><span class="p">,</span><span class="n">param_coords</span><span class="p">,</span><span class="n">dim_uv</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">uvlist</span>
        </div>
<div class="viewcode-block" id="Sensor.sensorToParametric"><a class="viewcode-back" href="../../Sensor.html#pyvsim.Toolbox.Sensor.sensorToParametric">[docs]</a>    <span class="k">def</span> <span class="nf">sensorToParametric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sensor_coords</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform sensor coordinates :math:`(U,V)` in meters to parametric </span>
<span class="sd">        coordinates,</span>
<span class="sd">        :math:`(\\\overline{U},\\\overline{V})`.</span>

<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        param_coords : numpy.ndarray (N,2)</span>
<span class="sd">            The parametric coordinates in the range -1..1. </span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sensor_coords : numpy.ndarray (N,2)</span>
<span class="sd">            The sensor coordinates in meters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dim_uv</span>  <span class="o">=</span> <span class="mi">2</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">[</span><span class="mi">1</span><span class="p">:][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">uvlist</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&quot;ij,j-&gt;ij&quot;</span><span class="p">,</span><span class="n">sensor_coords</span><span class="p">,</span><span class="n">dim_uv</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">uvlist</span>
    </div>
<div class="viewcode-block" id="Sensor.sensorToPhysical"><a class="viewcode-back" href="../../Sensor.html#pyvsim.Toolbox.Sensor.sensorToPhysical">[docs]</a>    <span class="k">def</span> <span class="nf">sensorToPhysical</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sensor_coords</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform sensor coordinates :math:`(U,V)` in meters to world coordinates</span>

<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        param_coords : numpy.ndarray (N,2)</span>
<span class="sd">            The parametric coordinates in the range -1..1. </span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sensor_coords : numpy.ndarray (N,3)</span>
<span class="sd">            The sensor coordinates in meters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parametricToPhysical</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensorToParametric</span><span class="p">(</span><span class="n">sensor_coords</span><span class="p">))</span>
    </div>
<div class="viewcode-block" id="Sensor.sensorToPixel"><a class="viewcode-back" href="../../Sensor.html#pyvsim.Toolbox.Sensor.sensorToPixel">[docs]</a>    <span class="k">def</span> <span class="nf">sensorToPixel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transforms (normalized) parametric coordinates into pixel position on the</span>
<span class="sd">        sensor.</span>
<span class="sd">        </span>
<span class="sd">        There is an inversion of the UV columns because of the unfortunate </span>
<span class="sd">        parametric coordinate system that maps:</span>
<span class="sd">         </span>
<span class="sd">        u -&gt; sensor.z</span>
<span class="sd">        v -&gt; sensor.y</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coords : numpy.ndarray (N,3)</span>
<span class="sd">            The position in the sensor in normalized coordinates (range -1..1)</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pixels : numpy.ndarray (N,2)</span>
<span class="sd">            The fractional position in sensor pixels in the format [row column] </span>
<span class="sd">        </span>
<span class="sd">        DOES NOT CHECK IF OUTSIDE SENSOR BOUNDARIES!!!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parametricToPixel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensorToParametric</span><span class="p">(</span><span class="n">coords</span><span class="p">))</span>
    
    </div>
<div class="viewcode-block" id="Sensor.parametricToPixel"><a class="viewcode-back" href="../../Sensor.html#pyvsim.Toolbox.Sensor.parametricToPixel">[docs]</a>    <span class="k">def</span> <span class="nf">parametricToPixel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">coordinates</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transforms (normalized) parametric coordinates into pixel position on the</span>
<span class="sd">        sensor.</span>
<span class="sd">        </span>
<span class="sd">        There is an inversion of the UV columns because of the unfortunate </span>
<span class="sd">        parametric coordinate system that maps:</span>
<span class="sd">         </span>
<span class="sd">        u -&gt; sensor.z</span>
<span class="sd">        v -&gt; sensor.y</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coords : numpy.ndarray (N,3)</span>
<span class="sd">            The position in the sensor in normalized coordinates (range -1..1)</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pixels : numpy.ndarray (N,2)</span>
<span class="sd">            The fractional position in sensor pixels in the format [row column] </span>
<span class="sd">        </span>
<span class="sd">        DOES NOT CHECK IF OUTSIDE SENSOR BOUNDARIES!!!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">coordinates</span><span class="p">[:,::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution</span>    
    </div>
<div class="viewcode-block" id="Sensor.physicalToPixel"><a class="viewcode-back" href="../../Sensor.html#pyvsim.Toolbox.Sensor.physicalToPixel">[docs]</a>    <span class="k">def</span> <span class="nf">physicalToPixel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">coords</span><span class="p">):</span>   
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transforms world coordinates into a position in the sensor, given in</span>
<span class="sd">        pixels</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coords : numpy.ndarray (N,3)</span>
<span class="sd">            The position in world coordinates</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pixels : numpy.ndarray (N,2)</span>
<span class="sd">            The fractional position in sensor pixels in the format [row column] </span>
<span class="sd">        </span>
<span class="sd">        DOES NOT CHECK IF OUTSIDE SENSOR BOUNDARIES!!!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">physicalToParametric</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution</span>
    </div>
    <span class="k">def</span> <span class="nf">_recordParticles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">coords</span><span class="p">,</span><span class="n">energy</span><span class="p">,</span><span class="n">wavelength</span><span class="p">,</span><span class="n">diameter</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        coords     - [u,v] sensor coordinates of the recorded point</span>
<span class="sd">        energy     - J -   energy which is captured by the lenses</span>
<span class="sd">        wavelength - m -   illumination wavelength</span>
<span class="sd">        diameter   - m -   particle image diameter</span>
<span class="sd">        </span>
<span class="sd">        Writes the diffraction-limited image of a particle to the</span>
<span class="sd">        sensor. This logic was described by Lecordier and </span>
<span class="sd">        Westerweel on the SIG publication</span>
<span class="sd">        </span>
<span class="sd">        The method is vectorized, but that demands the creation of</span>
<span class="sd">        very large tensors (X, Y, gX0, gX1, gY0, gY1), which can</span>
<span class="sd">        lead to a crash of the python intepreter. This is one of</span>
<span class="sd">        the reasons that control of this function is given to the</span>
<span class="sd">        public readSensor method.</span>
<span class="sd">        </span>
<span class="sd">        Another issue is the masksize parameter. This determines the</span>
<span class="sd">        dimensions of the tensor, which are::</span>
<span class="sd">        </span>
<span class="sd">        [np of particles, masksize[0], masksize[1]]</span>
<span class="sd">        </span>
<span class="sd">        This is because the tensors can be seen as a pile of &quot;stickers&quot; </span>
<span class="sd">        each with a particle image on them. Then they are &quot;glued&quot; to </span>
<span class="sd">        the sensor at the correct position.</span>
<span class="sd">        </span>
<span class="sd">        The masksize must be big enough that the largest particle image</span>
<span class="sd">        will still fit to the &quot;sticker&quot;. However, an evaluation of the</span>
<span class="sd">        error funcion (which is the integral of the gaussian profile) </span>
<span class="sd">        is executed 4 times for each element of the tensors. So, if we </span>
<span class="sd">        have one very large image and many small ones, we waste a lot</span>
<span class="sd">        of computing pulseEnergy.</span>
<span class="sd">        </span>
<span class="sd">        Do not forget the sign convention for the image</span>
<span class="sd">        --|----------------------------------&gt; </span>
<span class="sd">          |                            |     z</span>
<span class="sd">          |                            |</span>
<span class="sd">          |            A____________   | </span>
<span class="sd">          |            |            |  |</span>
<span class="sd">          |            |            |  |      A = anchor</span>
<span class="sd">          |            |      C     |  |      C = particle center</span>
<span class="sd">          |            |            |  | </span>
<span class="sd">          |            |____________|  |</span>
<span class="sd">          v ___________________________| </span>
<span class="sd">           y</span>
<span class="sd">           </span>
<span class="sd">          When particle image is partially out of the image limits, the </span>
<span class="sd">          computation is done over a partially useless domain, but </span>
<span class="sd">          remains correct.</span>
<span class="sd">          </span>
<span class="sd">        --|----------------------------------&gt; </span>
<span class="sd">          |                            |     z</span>
<span class="sd">          |                            |</span>
<span class="sd">          |                            | </span>
<span class="sd">          |               A____________|</span>
<span class="sd">          |               |            |      A = anchor</span>
<span class="sd">          |               |            |      C = particle center</span>
<span class="sd">          |               |            | </span>
<span class="sd">          |               |            |</span>
<span class="sd">          v ______________|___________C| </span>
<span class="sd">           y</span>
<span class="sd">        </span>
<span class="sd">        The program performs an integration of a 2D gaussian distribution </span>
<span class="sd">        over the sensitive areas of the pixel (defined by the fill ratio). </span>
<span class="sd">                     </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Classical formula  E =    h*c        h = 6.62607e-34 J*s</span>
        <span class="c">#                        ---------     c = 299 792 458 m/s</span>
        <span class="c">#                          lambda</span>
        <span class="n">photonEnergy</span> <span class="o">=</span> <span class="mf">6.62607e-34</span><span class="o">*</span><span class="mi">299792458</span><span class="o">/</span><span class="n">wavelength</span>
        <span class="n">totalPhotons</span> <span class="o">=</span> <span class="n">energy</span> <span class="o">/</span> <span class="n">photonEnergy</span>
        <span class="n">sX</span>           <span class="o">=</span> <span class="p">(</span><span class="n">diameter</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">pixelSize</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="mf">0.44</span><span class="o">/</span><span class="mf">1.22</span><span class="p">)</span>
        <span class="n">sY</span>           <span class="o">=</span> <span class="p">(</span><span class="n">diameter</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">pixelSize</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="mf">0.44</span><span class="o">/</span><span class="mf">1.22</span><span class="p">)</span>
        <span class="c">#</span>
        <span class="c"># Filtering useless results</span>
        <span class="c">#</span>
        <span class="n">npts</span>         <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">killist</span>      <span class="o">=</span> <span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">npts</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span> 
                        <span class="p">(</span><span class="n">coords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mf">1.01</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">coords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mf">1.01</span><span class="p">)</span> <span class="o">*</span> 
                        <span class="p">(</span><span class="n">coords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mf">1.01</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">coords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mf">1.01</span><span class="p">)</span> <span class="o">*</span> 
                        <span class="p">((</span><span class="n">totalPhotons</span> <span class="o">/</span> <span class="p">(</span><span class="n">sX</span> <span class="o">*</span> <span class="n">sY</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">))</span>

        <span class="n">killist</span>      <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">killist</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">killist</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span>
        
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">killist</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">diameter</span><span class="p">):</span>
            <span class="n">diameter2</span>    <span class="o">=</span> <span class="n">diameter</span><span class="p">[</span><span class="n">killist</span><span class="p">]</span>
            <span class="n">coords2</span>      <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="n">killist</span><span class="p">]</span>
            <span class="n">totalPhotons</span> <span class="o">=</span> <span class="n">totalPhotons</span><span class="p">[</span><span class="n">killist</span><span class="p">]</span>
            <span class="n">sX</span>           <span class="o">=</span> <span class="n">sX</span><span class="p">[</span><span class="n">killist</span><span class="p">]</span>
            <span class="n">sY</span>           <span class="o">=</span> <span class="n">sY</span><span class="p">[</span><span class="n">killist</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">diameter2</span>    <span class="o">=</span> <span class="n">diameter</span>
            <span class="n">coords2</span>      <span class="o">=</span> <span class="n">coords</span>

        <span class="n">pixels</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensorToPixel</span><span class="p">(</span><span class="n">coords2</span><span class="p">)</span> 

        <span class="c">#</span>
        <span class="c"># Auxiliary variables for vectorization</span>
        <span class="c">#</span>
        <span class="n">npts</span>            <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">coords2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        
        <span class="n">totalPhotons</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">totalPhotons</span><span class="p">,(</span><span class="n">npts</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">pixelX</span>          <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">pixels</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],(</span><span class="n">npts</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">pixelY</span>          <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">pixels</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],(</span><span class="n">npts</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> 
        <span class="n">sX</span>              <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">sX</span><span class="p">,(</span><span class="n">npts</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">sY</span>              <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">sY</span><span class="p">,(</span><span class="n">npts</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">frX</span>             <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fillRatio</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">frY</span>             <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fillRatio</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c"># this masksize guarantees that the particle image will not be cropped</span>
        <span class="c"># when the particle size is too small</span>
        <span class="c"># </span>
        <span class="c"># here we take only the worst case</span>

        <span class="n">masksize</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">masksize</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mf">2.25</span><span class="o">*</span><span class="n">diameter2</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">pixelSize</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">masksize</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mf">2.25</span><span class="o">*</span><span class="n">diameter2</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">pixelSize</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> 
        <span class="n">masksize</span><span class="p">[</span><span class="n">masksize</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="n">masksize</span><span class="p">[</span><span class="n">masksize</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="p">)</span> 

        <span class="c"># Defines the anchor position (cf. documentation above)</span>
        <span class="n">anchor</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">pixels</span> <span class="o">-</span> <span class="n">masksize</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
               
        <span class="c"># Important to verify if anchor will not force an incorrect matrix addition</span>
        <span class="c"># Case anchor has negative elements, stick them to the pixel zero </span>
        <span class="n">anchor</span><span class="p">[</span><span class="n">anchor</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">*</span> <span class="n">anchor</span><span class="p">[</span><span class="n">anchor</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span>
        <span class="c"># Case anchor element is out of the matrix boundaries</span>
        <span class="n">anchor</span><span class="p">[:,</span><span class="mi">0</span><span class="p">][</span><span class="n">anchor</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">masksize</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> 
                    <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution</span> <span class="o">-</span> <span class="n">masksize</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">anchor</span><span class="p">[:,</span><span class="mi">1</span><span class="p">][</span><span class="n">anchor</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">masksize</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> 
                    <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution</span> <span class="o">-</span> <span class="n">masksize</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">anchorX</span> <span class="o">=</span> <span class="n">anchor</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">anchorY</span> <span class="o">=</span> <span class="n">anchor</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">anchorX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">anchorX</span><span class="p">,</span> <span class="p">(</span><span class="n">npts</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">anchorY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">anchorY</span><span class="p">,</span> <span class="p">(</span><span class="n">npts</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
       

        <span class="p">[</span><span class="n">Y</span><span class="p">,</span><span class="n">X</span><span class="p">]</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">masksize</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">masksize</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

        <span class="n">X</span>       <span class="o">=</span> <span class="n">X</span> <span class="o">+</span> <span class="n">anchorX</span> <span class="o">-</span> <span class="n">pixelX</span> 
        <span class="n">Y</span>       <span class="o">=</span> <span class="n">Y</span> <span class="o">+</span> <span class="n">anchorY</span> <span class="o">-</span> <span class="n">pixelY</span>
   
        <span class="c"># Magic Airy integral, in fact this is a 2D integral on the sensitive</span>
        <span class="c"># area of the pixel (defined by the fill ratio)</span>
        <span class="n">gX0</span> <span class="o">=</span> <span class="n">erf</span><span class="p">((</span><span class="n">X</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">frX</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="o">/</span><span class="n">sX</span><span class="p">)</span>
        <span class="n">gX1</span> <span class="o">=</span> <span class="n">erf</span><span class="p">((</span><span class="n">X</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">frX</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="o">/</span><span class="n">sX</span><span class="p">)</span>
        <span class="n">gY0</span> <span class="o">=</span> <span class="n">erf</span><span class="p">((</span><span class="n">Y</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">frY</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="o">/</span><span class="n">sY</span><span class="p">)</span>
        <span class="n">gY1</span> <span class="o">=</span> <span class="n">erf</span><span class="p">((</span><span class="n">Y</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">frY</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="o">/</span><span class="n">sY</span><span class="p">)</span>    

        <span class="n">level</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="p">((</span><span class="n">gX1</span><span class="o">-</span><span class="n">gX0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">gY1</span><span class="o">-</span><span class="n">gY0</span><span class="p">))</span><span class="o">*</span> 
                 <span class="n">totalPhotons</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">quantumEfficiency</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">gain</span><span class="p">)</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="n">ax</span><span class="p">,</span><span class="n">ay</span><span class="p">))</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">anchor</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rawData</span><span class="p">[</span><span class="n">ax</span><span class="p">:</span><span class="n">ax</span><span class="o">+</span><span class="n">masksize</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ay</span><span class="p">:</span><span class="n">ay</span><span class="o">+</span><span class="n">masksize</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">level</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>

<div class="viewcode-block" id="Sensor.recordParticles"><a class="viewcode-back" href="../../Sensor.html#pyvsim.Toolbox.Sensor.recordParticles">[docs]</a>    <span class="k">def</span> <span class="nf">recordParticles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                        <span class="n">coords</span><span class="p">,</span>
                        <span class="n">energy</span><span class="p">,</span>
                        <span class="n">wavelength</span><span class="p">,</span>
                        <span class="n">diameter</span><span class="p">,</span>
                        <span class="n">ignoreLarge</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        coords     - [u,v] sensor coordinates of the recorded point</span>
<span class="sd">        energy     - J -   energy which is captured by the lenses</span>
<span class="sd">        wavelength - m -   illumination wavelength</span>
<span class="sd">        diameter   - m -   particle image diameter</span>
<span class="sd">        </span>
<span class="sd">        This is the front-end of the _recordParticle method, its main input</span>
<span class="sd">        is an array of sensor coordinates, representing the particle image</span>
<span class="sd">        centers.</span>
<span class="sd">        </span>
<span class="sd">        The other inputs can be either arrays (e.g. for particle with </span>
<span class="sd">        varying diameters) or scalars (e.g. for all particles with same</span>
<span class="sd">        diameter). It is more or less obvious that the arrays must have</span>
<span class="sd">        the same length as the coordinate arrays.</span>
<span class="sd">        </span>
<span class="sd">        Another issue is that the recording is much less efficient</span>
<span class="sd">        when particle image sizes varying size (the source of this issue</span>
<span class="sd">        is at the _recordParticles documentation). So some tricks (such</span>
<span class="sd">        as sorting by particle size) are used to reduce this effect. This</span>
<span class="sd">        procedure is made when the standard deviation exceeds 1/10th of the</span>
<span class="sd">        particle diameter (ajustable by the STD_PARAM constant at the</span>
<span class="sd">        beginning of the module).</span>
<span class="sd">        </span>
<span class="sd">        Finally, as the recording itself is vectorized, but uses too much </span>
<span class="sd">        memory, it is made in steps. If you find problems too often, adjust</span>
<span class="sd">        the following constants at the header of this module::</span>
<span class="sd">        </span>
<span class="sd">        MEMSIZE - maximum acceptable number of elements in a numpy.ndarray</span>
<span class="sd">        </span>
<span class="sd">        MEM_SAFETY - factor of safety</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># filter out too large particles</span>
        <span class="k">if</span> <span class="n">ignoreLarge</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">threshold</span> <span class="o">=</span> <span class="n">ignoreLarge</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">diameter</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">diameter</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">:</span>
                <span class="k">return</span>
            
            <span class="n">smallparticles</span> <span class="o">=</span> <span class="n">diameter</span> <span class="o">&lt;</span> <span class="n">threshold</span>
            
            <span class="n">diameter</span> <span class="o">=</span> <span class="n">diameter</span><span class="p">[</span><span class="n">smallparticles</span><span class="p">]</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="n">smallparticles</span><span class="p">,:]</span> 
            
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">wavelength</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">wavelength</span> <span class="o">=</span> <span class="n">wavelength</span><span class="p">[</span><span class="n">smallparticles</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">energy</span> <span class="o">=</span> <span class="n">energy</span><span class="p">[</span><span class="n">smallparticles</span><span class="p">]</span>     
                      
                
        <span class="k">print</span> <span class="s">&quot;There are </span><span class="si">%i</span><span class="s"> particles to be recorded&quot;</span> <span class="o">%</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
                
        <span class="n">meanDiameter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">diameter</span><span class="p">)</span>
        <span class="n">meanDiameter</span> <span class="o">=</span> <span class="n">meanDiameter</span>     <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pixelSize</span><span class="p">)</span>
        <span class="n">stepMax</span>      <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">MEMSIZE</span> <span class="o">/</span> <span class="p">(</span><span class="n">MEM_SAFETY</span> <span class="o">*</span> <span class="n">meanDiameter</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">stepMax</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">stepMax</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">nparts</span>       <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">stepMax</span> <span class="o">&lt;</span> <span class="n">nparts</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">diameter</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">STD_PARAM</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">diameter</span><span class="p">):</span>
            <span class="k">print</span> <span class="s">&quot;Sorting&quot;</span>
            <span class="n">indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">diameter</span><span class="p">)</span>
            <span class="n">coords</span>  <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="n">indexes</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">indexes</span> <span class="o">=</span> <span class="bp">None</span>
                 
        <span class="c"># Adjusting the inputs, so that _recordParticle will get uniform</span>
        <span class="c"># arrays always   </span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">indexes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">energy</span>  <span class="o">=</span> <span class="n">energy</span><span class="p">[</span><span class="n">indexes</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">energy</span>  <span class="o">=</span> <span class="n">energy</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nparts</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">wavelength</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">indexes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">wavelength</span> <span class="o">=</span> <span class="n">wavelength</span><span class="p">[</span><span class="n">indexes</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">wavelength</span> <span class="o">=</span> <span class="n">wavelength</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nparts</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">diameter</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">indexes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">diameter</span> <span class="o">=</span> <span class="n">diameter</span><span class="p">[</span><span class="n">indexes</span><span class="p">]</span>   
        <span class="k">else</span><span class="p">:</span>
            <span class="n">diameter</span> <span class="o">=</span> <span class="n">diameter</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nparts</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">stepMax</span> <span class="o">&lt;</span> <span class="n">nparts</span><span class="p">:</span>  
            <span class="k">print</span> <span class="s">&quot;Recording partials in steps of </span><span class="si">%i</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">stepMax</span>             
            <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">nrec</span> <span class="o">=</span> <span class="mi">0</span>
            
            <span class="k">while</span> <span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">stepMax</span> <span class="o">&lt;</span> <span class="n">nparts</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_recordParticles</span><span class="p">(</span><span class="n">coords</span>     <span class="p">[</span><span class="n">k</span><span class="o">*</span><span class="n">stepMax</span><span class="p">:(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">stepMax</span><span class="p">],</span> 
                                      <span class="n">energy</span>     <span class="p">[</span><span class="n">k</span><span class="o">*</span><span class="n">stepMax</span><span class="p">:(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">stepMax</span><span class="p">],</span> 
                                      <span class="n">wavelength</span> <span class="p">[</span><span class="n">k</span><span class="o">*</span><span class="n">stepMax</span><span class="p">:(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">stepMax</span><span class="p">],</span> 
                                      <span class="n">diameter</span>   <span class="p">[</span><span class="n">k</span><span class="o">*</span><span class="n">stepMax</span><span class="p">:(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">stepMax</span><span class="p">])</span>
                <span class="n">nrec</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="n">k</span><span class="o">*</span><span class="n">stepMax</span><span class="p">:(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">stepMax</span><span class="p">],</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_recordParticles</span><span class="p">(</span><span class="n">coords</span>     <span class="p">[</span><span class="n">k</span><span class="o">*</span><span class="n">stepMax</span><span class="p">:],</span> 
                                  <span class="n">energy</span>     <span class="p">[</span><span class="n">k</span><span class="o">*</span><span class="n">stepMax</span><span class="p">:],</span> 
                                  <span class="n">wavelength</span> <span class="p">[</span><span class="n">k</span><span class="o">*</span><span class="n">stepMax</span><span class="p">:],</span> 
                                  <span class="n">diameter</span>   <span class="p">[</span><span class="n">k</span><span class="o">*</span><span class="n">stepMax</span><span class="p">:])</span>
            <span class="n">nrec</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="n">k</span><span class="o">*</span><span class="n">stepMax</span><span class="p">:],</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">print</span> <span class="s">&quot;Recorded </span><span class="si">%i</span><span class="s"> particles in </span><span class="si">%i</span><span class="s"> steps&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">nrec</span><span class="p">,</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;Recording total&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_recordParticles</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">energy</span><span class="p">,</span> <span class="n">wavelength</span><span class="p">,</span> <span class="n">diameter</span><span class="p">)</span>
</div></div>
<div class="viewcode-block" id="Lens"><a class="viewcode-back" href="../../Lens.html#pyvsim.Toolbox.Lens">[docs]</a><span class="k">class</span> <span class="nc">Lens</span><span class="p">(</span><span class="n">Primitives</span><span class="o">.</span><span class="n">Part</span><span class="p">,</span> <span class="n">Core</span><span class="o">.</span><span class="n">PyvsimDatabasable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class represents an objective lens. The implemented model is a thick,</span>
<span class="sd">    pupil-centric lens as described by `Aggarwal and Ahuja </span>
<span class="sd">    &lt;http://link.springer.com/article/10.1023%2FA%3A1016324132583&gt;`_ .</span>
<span class="sd">    </span>
<span class="sd">    This means that the center of projection is assumed to be at the center</span>
<span class="sd">    of the entrance pupil.</span>
<span class="sd">    </span>
<span class="sd">    This class generates the starting vectors for the ray tracing procedure. One</span>
<span class="sd">    caveat is that it is not possible to execute ray tracing from the back of the</span>
<span class="sd">    lens (i.e. from the sensor to the lens), as the rays are assumed straight</span>
<span class="sd">    between these two points. This can be a problem when modelling stacked lenses,</span>
<span class="sd">    that have to be substituted by an equivalent one.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">Primitives</span><span class="o">.</span><span class="n">Part</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">Core</span><span class="o">.</span><span class="n">PyvsimDatabasable</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span>            <span class="o">=</span> <span class="s">&#39;Lens &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dbName</span>          <span class="o">=</span> <span class="s">&quot;Lenses&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dbParameters</span>    <span class="o">=</span> <span class="p">[</span><span class="s">&quot;color&quot;</span><span class="p">,</span> <span class="s">&quot;opacity&quot;</span><span class="p">,</span> <span class="s">&quot;diameter&quot;</span><span class="p">,</span> <span class="s">&quot;length&quot;</span><span class="p">,</span>
                                <span class="s">&quot;flangeFocalDistance&quot;</span><span class="p">,</span> <span class="s">&quot;F&quot;</span><span class="p">,</span> <span class="s">&quot;H_fore_scalar&quot;</span><span class="p">,</span>
                                <span class="s">&quot;H_aft_scalar&quot;</span><span class="p">,</span> <span class="s">&quot;E_scalar&quot;</span><span class="p">,</span> <span class="s">&quot;X_scalar&quot;</span><span class="p">,</span>
                                <span class="s">&quot;_Edim&quot;</span><span class="p">,</span> <span class="s">&quot;_Xdim&quot;</span><span class="p">,</span> <span class="s">&quot;distortionParameters&quot;</span><span class="p">]</span>
        <span class="c"># Plotting parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">color</span>                        <span class="o">=</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.2</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">opacity</span>                      <span class="o">=</span> <span class="mf">0.8</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span>                     <span class="o">=</span> <span class="mf">0.076</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span>                       <span class="o">=</span> <span class="mf">0.091</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_createPoints</span><span class="p">()</span>
        <span class="c"># Main planes model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flangeFocalDistance</span>          <span class="o">=</span>  <span class="mf">0.0440</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">F</span>                            <span class="o">=</span>  <span class="mf">0.1000</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_H_fore_scalar</span>               <span class="o">=</span>  <span class="mf">0.0460</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_H_aft_scalar</span>                <span class="o">=</span>  <span class="mf">0.0560</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_E_scalar</span>                    <span class="o">=</span>  <span class="mf">0.0214</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_X_scalar</span>                    <span class="o">=</span>  <span class="mf">0.0362568218298555</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Edim</span>                        <span class="o">=</span>  <span class="mf">0.1000</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Xdim</span>                        <span class="o">=</span>  <span class="mf">0.0802568218</span>
        <span class="c"># Adjustable parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_focusingDistance</span>            <span class="o">=</span>  <span class="mi">10</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">macro</span>                        <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aperture</span>                     <span class="o">=</span>  <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distortionParameters</span>         <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span>
                                                      <span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span>
                                                      <span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
        <span class="c">#Calculated parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">focusingOffset</span>               <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">PinholeFore</span>                  <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">PinholeAft</span>                   <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calculatePositions</span><span class="p">()</span>
        
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">H_fore</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_fore_scalar</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span>
    <span class="nd">@H_fore.setter</span>
    <span class="k">def</span> <span class="nf">H_fore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>     <span class="bp">self</span><span class="o">.</span><span class="n">_H_fore_scalar</span> <span class="o">=</span> <span class="n">h</span> 
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">H_aft</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>         <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_aft_scalar</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span>
    <span class="nd">@H_aft.setter</span>
    <span class="k">def</span> <span class="nf">H_aft</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>      <span class="bp">self</span><span class="o">.</span><span class="n">H_aft_scalar</span> <span class="o">=</span> <span class="n">h</span>      
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">H_fore_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_H_fore_scalar</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">focusingOffset</span><span class="p">)</span>
    <span class="nd">@property</span>        
    <span class="k">def</span> <span class="nf">H_aft_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_H_aft_scalar</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">focusingOffset</span><span class="p">)</span>
    <span class="nd">@property</span>        
    <span class="k">def</span> <span class="nf">E_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>      <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_E_scalar</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">focusingOffset</span><span class="p">)</span>
    <span class="nd">@property</span>        
    <span class="k">def</span> <span class="nf">X_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>      <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_X_scalar</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">focusingOffset</span><span class="p">)</span>           
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">E</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>             <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">E_scalar</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span>
    <span class="nd">@E.setter</span>
    <span class="k">def</span> <span class="nf">E</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>          <span class="bp">self</span><span class="o">.</span><span class="n">E_scalar</span> <span class="o">=</span> <span class="n">e</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">X</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>             <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">X_scalar</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span>
    <span class="nd">@X.setter</span>
    <span class="k">def</span> <span class="nf">X</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>          <span class="bp">self</span><span class="o">.</span><span class="n">X_scalar</span> <span class="o">=</span> <span class="n">x</span>
                        
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">focusingDistance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_focusingDistance</span>
    <span class="nd">@focusingDistance.setter</span>
    <span class="k">def</span> <span class="nf">focusingDistance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">distance</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_focusingDistance</span> <span class="o">=</span> <span class="n">distance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calculatePositions</span><span class="p">()</span>
        
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">Edim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Edim</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">aperture</span>
    <span class="nd">@Edim.setter</span>
    <span class="k">def</span> <span class="nf">Edim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entrancePupilDiameter</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Edim</span> <span class="o">=</span> <span class="n">entrancePupilDiameter</span>
        
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">Xdim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Xdim</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">aperture</span>
    <span class="nd">@Xdim.setter</span>
    <span class="k">def</span> <span class="nf">Xdim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pupilDiameter</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Xdim</span> <span class="o">=</span> <span class="n">pupilDiameter</span>   
    
<div class="viewcode-block" id="Lens.display"><a class="viewcode-back" href="../../Lens.html#pyvsim.Toolbox.Lens.display">[docs]</a>    <span class="k">def</span> <span class="nf">display</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method creates a plot showing the position of the lens notable</span>
<span class="sd">        planes (the two main planes, the pupils and the focusing offset). This</span>
<span class="sd">        is intended for debugging purposes, or better understanding how the </span>
<span class="sd">        lens work.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">facecolor</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">hold</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s">&quot;equal&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="n">which</span> <span class="o">=</span> <span class="s">&quot;both&quot;</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="s">&quot;both&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&quot;Notable planes position, reference - lens flange&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">diameter</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
                  <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">diameter</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
                  <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">diameter</span><span class="o">/</span><span class="mi">2</span><span class="p">],</span>
                 <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
                 <span class="s">&quot;k&quot;</span><span class="p">,</span> 
                 <span class="c">#label=&quot;External contour&quot;,</span>
                 <span class="n">linewidth</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
                 <span class="p">[</span><span class="o">-</span><span class="mf">0.1</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">,</span><span class="mf">1.1</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">],</span>
                 <span class="s">&quot;k-.&quot;</span><span class="p">,</span> 
                 <span class="c">#label=&quot;Centerline&quot;,</span>
                 <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">diameter</span><span class="o">/</span><span class="mf">1.5</span><span class="p">,</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span><span class="o">/</span><span class="mf">1.5</span><span class="p">],</span>
                 <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">H_aft_scalar</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">H_aft_scalar</span><span class="p">],</span>
                 <span class="s">&quot;b&quot;</span><span class="p">,</span> 
                 <span class="n">label</span><span class="o">=</span><span class="s">&quot;H&#39;&quot;</span><span class="p">,</span>
                 <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">diameter</span><span class="o">/</span><span class="mf">1.5</span><span class="p">,</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span><span class="o">/</span><span class="mf">1.5</span><span class="p">],</span>
                 <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">H_fore_scalar</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">H_fore_scalar</span><span class="p">],</span>
                 <span class="s">&quot;r&quot;</span><span class="p">,</span> 
                 <span class="n">label</span><span class="o">=</span><span class="s">&quot;H&quot;</span><span class="p">,</span>
                 <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>     
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">diameter</span><span class="o">/</span><span class="mf">1.5</span><span class="p">,</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span><span class="o">/</span><span class="mf">1.5</span><span class="p">],</span>
                 <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">focusingOffset</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">focusingOffset</span><span class="p">],</span>
                 <span class="s">&quot;k&quot;</span><span class="p">,</span> 
                 <span class="n">label</span><span class="o">=</span><span class="s">&quot;d&#39;&quot;</span><span class="p">,</span>
                 <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">diameter</span><span class="o">/</span><span class="mf">1.5</span><span class="p">,</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">Edim</span><span class="o">/</span><span class="mi">2</span><span class="p">],</span>
                 <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">E_scalar</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">E_scalar</span><span class="p">],</span>
                 <span class="s">&quot;r&quot;</span><span class="p">,</span> 
                 <span class="n">label</span><span class="o">=</span><span class="s">&quot;E&quot;</span><span class="p">,</span>
                 <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>  
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">diameter</span><span class="o">/</span><span class="mf">1.5</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">Edim</span><span class="o">/</span><span class="mi">2</span><span class="p">],</span>
                 <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">E_scalar</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">E_scalar</span><span class="p">],</span>
                 <span class="s">&quot;r&quot;</span><span class="p">,</span> 
<span class="c">#                 label=&quot;E&quot;,</span>
                 <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>         
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">diameter</span><span class="o">/</span><span class="mf">1.5</span><span class="p">,</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">Xdim</span><span class="o">/</span><span class="mi">2</span><span class="p">],</span>
                 <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">X_scalar</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">X_scalar</span><span class="p">],</span>
                 <span class="s">&quot;b&quot;</span><span class="p">,</span> 
                 <span class="n">label</span><span class="o">=</span><span class="s">&quot;X&quot;</span><span class="p">,</span>
                 <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>  
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">diameter</span><span class="o">/</span><span class="mf">1.5</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">Xdim</span><span class="o">/</span><span class="mi">2</span><span class="p">],</span>
                 <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">X_scalar</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">X_scalar</span><span class="p">],</span>
                 <span class="s">&quot;b&quot;</span><span class="p">,</span> 
<span class="c">#                 label=&quot;X&quot;,</span>
                 <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>            
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
             
               </div>
    <span class="k">def</span> <span class="nf">_calculatePositions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate some important points, must be called whenever the lens </span>
<span class="sd">        is moved.</span>
<span class="sd">        </span>
<span class="sd">        The position of the exit pinhole is calculated as proposed by:</span>
<span class="sd">        </span>
<span class="sd">        Aggarwal, M. &amp; Ahuja, N. A </span>
<span class="sd">        Pupil-centric model of image formation </span>
<span class="sd">        Internation Journal of Computer Vision, 2002, 48, 195-214</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># First, we have to calculate d&#39;, which is the distance the lens</span>
        <span class="c"># has to offset to focus at the given &quot;focusingDistance&quot;</span>
        <span class="c">#   1            1                     1</span>
        <span class="c"># -----  =  ----------- + ----------------------------</span>
        <span class="c">#   F          F + d&#39;      focusingDistance - SH - d&#39;</span>
        <span class="c">#                                      </span>
        <span class="c">#             -(foc - F - H) +- sqrt((foc-f-H)**2 + 4*F**2))</span>
        <span class="c">#  dprime =  ----------------------------------------------</span>
        <span class="c">#                                  2</span>
        <span class="n">aux</span>     <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">focusingDistance</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">F</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_H_fore_scalar</span> <span class="o">+</span> 
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">flangeFocalDistance</span><span class="p">)</span>
        <span class="n">delta</span>   <span class="o">=</span> <span class="n">aux</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">d_line1</span>  <span class="o">=</span> <span class="p">(</span><span class="n">aux</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">delta</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">d_line2</span>  <span class="o">=</span> <span class="p">(</span><span class="n">aux</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">delta</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">macro</span><span class="p">:</span>
            <span class="n">d_line</span> <span class="o">=</span>  <span class="n">d_line2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d_line</span> <span class="o">=</span>  <span class="n">d_line1</span>
        
<span class="c">#        print &quot;------ FOCUS CALCULATION ------------------------&quot;</span>
<span class="c">#        print &quot;foc          : &quot;, self.focusingDistance</span>
<span class="c">#        print &quot;aux          : &quot;, aux</span>
<span class="c">#        print &quot;F            : &quot;, self.F</span>
<span class="c">#        print &quot;H            : &quot;, (self._H_fore_scalar + </span>
<span class="c">#                                                    self.flangeFocalDistance)</span>
<span class="c">#        print &quot;sqrt(delta)  : &quot;, np.sqrt(delta)</span>
<span class="c">#        print &quot;d_line       : &quot;, d_line</span>
<span class="c">#        print &quot;X            : &quot;, self.X</span>
<span class="c">#        print &quot;Hprime       : &quot;, self.H_aft</span>
<span class="c">#        print &quot;H            : &quot;, self.H_fore</span>
<span class="c">#        print &quot;E            : &quot;, self.E</span>
        
        <span class="c">#</span>
        <span class="c"># Now, we have to find the pseudo position of the pinhole (which is</span>
        <span class="c"># not H_fore.</span>
        <span class="n">v</span>                       <span class="o">=</span> <span class="n">d_line</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">F</span>
        <span class="n">a</span>                       <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_E_scalar</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_H_fore_scalar</span>
        <span class="n">v_bar</span>                   <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="n">a</span> <span class="o">-</span> <span class="n">v</span><span class="o">*</span><span class="n">a</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">F</span>
        
        
<span class="c">#        print &quot;foc   %.5f \nv     %.5f \na     %.5f \nv_bar %.5f&quot; % (self.focusingDistance, </span>
<span class="c">#                                                                     v, a, v_bar)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">focusingOffset</span>     <span class="o">=</span> <span class="n">d_line</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">PinholeAft</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="n">v_bar</span> <span class="o">-</span> 
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">flangeFocalDistance</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">PinholeFore</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">E</span>
        
<div class="viewcode-block" id="Lens.clearData"><a class="viewcode-back" href="../../Lens.html#pyvsim.Toolbox.Lens.clearData">[docs]</a>    <span class="k">def</span> <span class="nf">clearData</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        As the data from the Primitives.Part class that has to be cleaned is </span>
<span class="sd">        used only for ray tracing, the parent method is not called.</span>
<span class="sd">        </span>
<span class="sd">        The notable points, however, are recalculated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calculatePositions</span><span class="p">()</span>
        </div>
    <span class="k">def</span> <span class="nf">_createPoints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is needed to plot the lens. This will create and the</span>
<span class="sd">        points and the connectivity list of a  tube.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">NPTS</span>    <span class="o">=</span> <span class="mi">20</span>
        <span class="n">pts</span>     <span class="o">=</span> <span class="p">[]</span>
        <span class="n">conn</span>    <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NPTS</span><span class="p">):</span>
                <span class="n">pts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">*</span> 
                           <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">n</span><span class="o">/</span><span class="n">NPTS</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> 
                            <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">n</span><span class="o">/</span><span class="n">NPTS</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NPTS</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">conn</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="n">NPTS</span><span class="p">])</span>
            <span class="n">conn</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">n</span><span class="o">+</span><span class="n">NPTS</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="n">NPTS</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">conn</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">NPTS</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>        <span class="n">NPTS</span><span class="p">])</span>
        <span class="n">conn</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">NPTS</span><span class="p">,</span>   <span class="mi">2</span><span class="o">*</span><span class="n">NPTS</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">NPTS</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>        
            
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span>       <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connectivity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">conn</span><span class="p">)</span>
        
<div class="viewcode-block" id="Lens.rayVector"><a class="viewcode-back" href="../../Lens.html#pyvsim.Toolbox.Lens.rayVector">[docs]</a>    <span class="k">def</span> <span class="nf">rayVector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">p</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a set of points (e.g. in the sensor), will return a list of</span>
<span class="sd">        vectors representing the direction to be followed by ray tracing.       </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lensDistortion</span><span class="p">(</span><span class="n">Utils</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">PinholeAft</span> <span class="o">-</span> <span class="n">p</span><span class="p">))</span>
    </div>
<div class="viewcode-block" id="Lens.lensDistortion"><a class="viewcode-back" href="../../Lens.html#pyvsim.Toolbox.Lens.lensDistortion">[docs]</a>    <span class="k">def</span> <span class="nf">lensDistortion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vectors</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TODO - Implementation of radial distortion model</span>
<span class="sd">        &quot;&quot;&quot;</span> 
<span class="c">#        return vectors </span>
        <span class="n">angler</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&quot;ij,j-&gt;i&quot;</span><span class="p">,</span><span class="n">vectors</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">))</span>
        <span class="n">angler</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">angler</span><span class="p">,(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">angley</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&quot;ij,j-&gt;i&quot;</span><span class="p">,</span><span class="n">vectors</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">))</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">angley</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">angley</span><span class="p">,(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">anglez</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&quot;ij,j-&gt;i&quot;</span><span class="p">,</span><span class="n">vectors</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">))</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">anglez</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">anglez</span><span class="p">,(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        
        <span class="n">raxis</span>  <span class="o">=</span> <span class="n">Utils</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span><span class="n">vectors</span><span class="p">))</span>
        <span class="n">yaxis</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&quot;j,ij-&gt;ij&quot;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">angley</span><span class="p">))</span>
        <span class="n">zaxis</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&quot;j,ij-&gt;ij&quot;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">anglez</span><span class="p">))</span>
<span class="c">#        print &quot;BLAH blah&quot;</span>
<span class="c">#        print self.distortionParameters[0:4]</span>
<span class="c">#        print </span>
<span class="c">#        print np.hstack([angler,angler**2,angler**3,angler**4])</span>
<span class="c">#        print np.hstack([angley,angley**2,angley**3,angley**4])</span>
        <span class="n">d_angler</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&quot;j,ij-&gt;i&quot;</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">distortionParameters</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">],</span>
                             <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">angler</span><span class="p">,</span><span class="n">angler</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">angler</span><span class="o">**</span><span class="mi">3</span><span class="p">,</span><span class="n">angler</span><span class="o">**</span><span class="mi">4</span><span class="p">]))</span>
        <span class="n">d_angley</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&quot;j,ij-&gt;i&quot;</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">distortionParameters</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">8</span><span class="p">],</span>
                             <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">angley</span><span class="p">,</span><span class="n">angley</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">angley</span><span class="o">**</span><span class="mi">3</span><span class="p">,</span><span class="n">angley</span><span class="o">**</span><span class="mi">4</span><span class="p">]))</span>  
        <span class="n">d_anglez</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&quot;j,ij-&gt;i&quot;</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">distortionParameters</span><span class="p">[</span><span class="mi">8</span><span class="p">:</span><span class="mi">12</span><span class="p">],</span>
                             <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">anglez</span><span class="p">,</span><span class="n">anglez</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">anglez</span><span class="o">**</span><span class="mi">3</span><span class="p">,</span><span class="n">anglez</span><span class="o">**</span><span class="mi">4</span><span class="p">]))</span>   
        <span class="n">vectors</span> <span class="o">=</span> <span class="n">Utils</span><span class="o">.</span><span class="n">rotateVector</span><span class="p">(</span><span class="n">vectors</span><span class="p">,</span> <span class="n">d_angler</span><span class="p">,</span> <span class="n">raxis</span><span class="p">)</span>
        <span class="n">vectors</span> <span class="o">=</span> <span class="n">Utils</span><span class="o">.</span><span class="n">rotateVector</span><span class="p">(</span><span class="n">vectors</span><span class="p">,</span> <span class="n">d_angley</span><span class="p">,</span> <span class="n">yaxis</span><span class="p">)</span>
        <span class="n">vectors</span> <span class="o">=</span> <span class="n">Utils</span><span class="o">.</span><span class="n">rotateVector</span><span class="p">(</span><span class="n">vectors</span><span class="p">,</span> <span class="n">d_anglez</span><span class="p">,</span> <span class="n">zaxis</span><span class="p">)</span>     
        <span class="k">return</span> <span class="n">vectors</span>      
<span class="c">#        npts = np.size(vectors,0)</span>
<span class="c">#        # Gets the angle between v and the optical axis</span>
<span class="c">#        Ti = np.arccos(np.sum(self.x * \</span>
<span class="c">#                              np.reshape(vectors,(npts,1,GLOBAL_NDIM)),2)).squeeze()</span>
<span class="c">#                              </span>
<span class="c">#        To = np.sum(self.distortionParameters * \</span>
<span class="c">#                    np.array([Ti**4,Ti**3,Ti**2,Ti]),2)</span>
<span class="c">#        </span>
<span class="c">#        axis = Utils.normalize(np.cross(self.x,vectors))</span>
<span class="c">#        return Utils.rotateVector(vectors,(To-Ti),axis)</span>
            </div></div>
<div class="viewcode-block" id="Camera"><a class="viewcode-back" href="../../Camera.html#pyvsim.Toolbox.Camera">[docs]</a><span class="k">class</span> <span class="nc">Camera</span><span class="p">(</span><span class="n">Primitives</span><span class="o">.</span><span class="n">Assembly</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class represents a camera composed of a body (used only for display),</span>
<span class="sd">    a sensor and a lens, therefore it is an assembly.</span>
<span class="sd">    </span>
<span class="sd">    The main functions of this class are driving the sensor and the lens </span>
<span class="sd">    together, so that the user can call more logical functions (such as</span>
<span class="sd">    initialize) instead of using a complicated series of internal functions.</span>
<span class="sd">    </span>
<span class="sd">    The camera creates a mapping of world coordinates into sensor coordinates</span>
<span class="sd">    by using direct linear transformations (a pinhole model). Lens imperfections</span>
<span class="sd">    and ambient influence can be modeled by using several DLTs (which is </span>
<span class="sd">    controlled by the parameter mappingResolution).</span>
<span class="sd">    &quot;&quot;&quot;</span> 
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">Primitives</span><span class="o">.</span><span class="n">Assembly</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span>                       <span class="o">=</span> <span class="s">&#39;Camera &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lens</span>                       <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span>                     <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">body</span>                       <span class="o">=</span> <span class="bp">None</span>
        <span class="c"># Plotting properties</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">color</span>                      <span class="o">=</span> <span class="p">[</span><span class="mf">0.172</span><span class="p">,</span><span class="mf">0.639</span><span class="p">,</span><span class="mf">0.937</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">opacity</span>                    <span class="o">=</span> <span class="mf">0.650</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>                  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.175</span><span class="p">,</span><span class="mf">0.066</span><span class="p">,</span><span class="mf">0.084</span><span class="p">])</span>
        <span class="c"># Geometrical properties</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sensorPosition</span>             <span class="o">=</span> <span class="o">-</span><span class="mf">0.017526</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scheimpflugAngle</span>          <span class="o">=</span> <span class="mi">0</span>
        <span class="c"># Mapping properties</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mappingResolution</span>          <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">circleOfConfusionDiameter</span>  <span class="o">=</span> <span class="mf">29e-6</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">referenceWavelength</span>        <span class="o">=</span> <span class="mf">532e-9</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mapping</span>                    <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">detmapping</span>                 <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dmapping</span>                   <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">virtualApertureArea</span>        <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sensorSamplingCenters</span>      <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">physicalSamplingCenters</span>    <span class="o">=</span> <span class="bp">None</span>
        <span class="c"># Create and position subcomponents:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_positionComponents</span><span class="p">()</span>
        
    <span class="k">def</span> <span class="nf">clearData</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mapping</span>                    <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">detmapping</span>                 <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dmapping</span>                   <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">virtualApertureArea</span>        <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rawPupilSolidAngle</span>         <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sensorSamplingCenters</span>      <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">physicalSamplingCenters</span>    <span class="o">=</span> <span class="bp">None</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_items</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        
    <span class="nd">@property</span>
<div class="viewcode-block" id="Camera.bounds"><a class="viewcode-back" href="../../Camera.html#pyvsim.Toolbox.Camera.bounds">[docs]</a>    <span class="k">def</span> <span class="nf">bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This signals the ray tracing implementation that no attempt should be</span>
<span class="sd">        made to intersect rays with the camera</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">None</span>
    </div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">scheimpflugAngle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scheimpflugAngle</span>
    <span class="nd">@scheimpflugAngle.setter</span>
    <span class="k">def</span> <span class="nf">scheimpflugAngle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This unfortunate vicious behavior is implemented to make sure that the</span>
<span class="sd">        _scheimpflugAngle property is always up-to-date, and if one tries to set</span>
<span class="sd">        that a meaningful error message is given.</span>
<span class="sd">        </span>
<span class="sd">        If python supported real overloading, the problem would be solved easily</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Please use the setScheimpflugAngle function&quot;</span><span class="p">)</span>
    
<div class="viewcode-block" id="Camera.setScheimpflugAngle"><a class="viewcode-back" href="../../Camera.html#pyvsim.Toolbox.Camera.setScheimpflugAngle">[docs]</a>    <span class="k">def</span> <span class="nf">setScheimpflugAngle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is a convenience function to set the Scheimpflug angle as in a </span>
<span class="sd">        well-build adapter (which means that the pivoting is performed through</span>
<span class="sd">        the sensor center).</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        angle : float (radians)</span>
<span class="sd">            The scheimpflug angle</span>
<span class="sd">        axis : numpy.array (3)</span>
<span class="sd">            The axis of rotation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">alignTo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> 
                          <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> 
                          <span class="bp">None</span><span class="p">,</span> 
                          <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sensorPosition</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="o">-</span><span class="n">angle</span><span class="p">,</span>     <span class="n">axis</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sensorPosition</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sensorPosition</span><span class="p">)</span>
        </div>
    <span class="k">def</span> <span class="nf">_positionComponents</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is a shortcut to define the initial position of the camera,</span>
<span class="sd">        there is a definition of the initial positioning of the sensor and the </span>
<span class="sd">        lens.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lens</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">body</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="p">)</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">lens</span>           <span class="o">=</span> <span class="n">Lens</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span>         <span class="o">=</span> <span class="n">Sensor</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">body</span>           <span class="o">=</span> <span class="n">Primitives</span><span class="o">.</span><span class="n">Volume</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">color</span>     <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">color</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">opacity</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opacity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lens</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">body</span><span class="p">)</span>
        
        <span class="c"># Adaptation in case lens is not compatible with camera (different</span>
        <span class="c"># flange focal distances)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">*</span>
                            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">flangeFocalDistance</span> <span class="o">+</span> 
                             <span class="bp">self</span><span class="o">.</span><span class="n">sensorPosition</span><span class="p">))</span>
        
        <span class="c"># Sensor position adjustment</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sensorPosition</span><span class="p">)</span>
        
<div class="viewcode-block" id="Camera.mapPoints"><a class="viewcode-back" href="../../Camera.html#pyvsim.Toolbox.Camera.mapPoints">[docs]</a>    <span class="k">def</span> <span class="nf">mapPoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pts</span><span class="p">,</span> <span class="n">skipPupilAngle</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method determines the position that a set of points x,y,z map on</span>
<span class="sd">        the camera sensor.</span>
<span class="sd">        </span>
<span class="sd">        In order to optimize calculation speed, a lot of memory is used, but </span>
<span class="sd">        the method seems to run smoothly up to 2M points in a 5x5 mapping (2GB</span>
<span class="sd">        of available RAM) </span>
<span class="sd">        </span>
<span class="sd">        The number of elements in the bottleneck matrix is:</span>
<span class="sd">        </span>
<span class="sd">        N = npts * 3 * mappingResolution[0] * mappingResolution[1]</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pts : numpy.array (N,3)</span>
<span class="sd">            A collection of points in the space</span>
<span class="sd">            </span>
<span class="sd">        skipPupilAngle : boolean</span>
<span class="sd">            Setting this flag to true skip the step of calculating the solid</span>
<span class="sd">            angle formed by the given points and the pupils. This is used only</span>
<span class="sd">            in the initialization of the camera</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        uv : numpy.array (N,3)</span>
<span class="sd">            The points (in sensor homogeneous coordinates) mapped to the</span>
<span class="sd">            sensor</span>
<span class="sd">        w  : numpy.array (N)</span>
<span class="sd">            The distance from the center of projection, as calculated by the</span>
<span class="sd">            DLT matrix</span>
<span class="sd">        dudv : numpy.array (N,6)</span>
<span class="sd">            The derivatives of the coordinates u,v with respect to x,y,z in the</span>
<span class="sd">            following order:</span>
<span class="sd">            [du/dx,  du/dy,  du/dz,  dv/dx,  dv/dy,  dv/dz]</span>
<span class="sd">        lineOfSight : numpy.array (N,3)</span>
<span class="sd">            The line of sight vectors (the direction of the light ray that</span>
<span class="sd">            goes from the point to the camera center of projection)</span>
<span class="sd">        imdim : numpy.array(N)</span>
<span class="sd">            The diameter of the image as generated by a point source (consider</span>
<span class="sd">            geometrical size + diffraction-limited size)</span>
<span class="sd">        pupilSolidAngle : numpy.array(N)</span>
<span class="sd">            The solid angle formed by the entrance pupil and the given points. </span>
<span class="sd">            If flag skipPupilAngle is true, returns None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">npts</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="c"># Calculate vectors from samplingCenters to given points</span>
        <span class="n">d</span>       <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">physicalSamplingCenters</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">pts</span><span class="p">,(</span><span class="n">npts</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
        <span class="c">#print d.shape, d.nbytes</span>
        <span class="c"># Calculate squared norms of vectors</span>
        <span class="n">d</span>       <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&#39;ijkl,ijkl-&gt;ijk&#39;</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">d</span><span class="p">)</span>
        <span class="c"># Flatten arrays to find minima</span>
<span class="c">#        print self.physicalSamplingCenters</span>
<span class="c">#        print d</span>
        <span class="n">d</span>       <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">d</span><span class="p">,(</span><span class="n">npts</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="c">#        print d</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="c"># Calculate indexes</span>
<span class="c">#        print indexes</span>
        <span class="n">j</span>       <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">indexes</span><span class="p">,(</span><span class="bp">self</span><span class="o">.</span><span class="n">mappingResolution</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">i</span>       <span class="o">=</span> <span class="p">((</span><span class="n">indexes</span> <span class="o">-</span> <span class="n">j</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mappingResolution</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">i</span>       <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s">&#39;int&#39;</span><span class="p">)</span>
        <span class="c"># Calculate DLT</span>
        <span class="n">uvw</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&#39;ijk,ik-&gt;ij&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">mapping</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">],</span> 
                            <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">pts</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">npts</span><span class="p">,</span><span class="mi">1</span><span class="p">))]))</span>
        <span class="n">w</span>           <span class="o">=</span> <span class="n">uvw</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> 
        <span class="n">uv</span>          <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&quot;ij,i-&gt;ij&quot;</span><span class="p">,</span> <span class="n">uvw</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="o">/</span><span class="n">uvw</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
<span class="c">#        print i,j</span>
<span class="c">#        print self.dmapping[i,j].shape </span>
<span class="c">#        print result.shape                           </span>
        <span class="n">duvw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&#39;ijk,ik-&gt;ij&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">dmapping</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">],</span><span class="n">uvw</span><span class="p">)</span>
        <span class="n">duvw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&quot;ij,i-&gt;ij&quot;</span><span class="p">,</span> <span class="n">duvw</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">dudx</span>    <span class="o">=</span> <span class="n">duvw</span><span class="p">[:,:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">dvdx</span>    <span class="o">=</span> <span class="n">duvw</span><span class="p">[:,</span><span class="mi">3</span><span class="p">:]</span>
<span class="c">#        print dudx</span>
        <span class="n">lineofsight</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">dudx</span><span class="p">,</span><span class="n">dvdx</span><span class="p">)</span>
                    <span class="c"># cheap norm                   # invert if mirror                              </span>
        <span class="n">lineofsightnorm</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">lineofsight</span><span class="o">*</span><span class="n">lineofsight</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">*</span>
                           <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">detmapping</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]))</span>
        <span class="n">lineofsight</span>  <span class="o">=</span> <span class="o">-</span><span class="n">lineofsight</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">lineofsightnorm</span><span class="p">,(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
        
        <span class="sd">&quot;&quot;&quot;Calculate the diameter of the geometric image&quot;&quot;&quot;</span>
        <span class="n">pts_sensor</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">sensorToPhysical</span><span class="p">(</span><span class="n">uv</span><span class="p">)</span>
        
        <span class="n">HpS</span>         <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">H_aft</span> <span class="o">-</span> <span class="n">pts_sensor</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">x</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">HpX</span>         <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">X_scalar</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">H_aft_scalar</span>
        
        <span class="n">pprime</span>      <span class="o">=</span> <span class="n">w</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">E_scalar</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">H_fore_scalar</span>
        <span class="n">p</span>           <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">F</span> <span class="o">*</span> <span class="n">pprime</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">pprime</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">F</span><span class="p">)</span>

        <span class="n">imdim</span>       <span class="o">=</span> <span class="mi">0</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">Xdim</span> <span class="o">*</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">HpS</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">HpX</span><span class="p">)</span>
        <span class="c"># Diffraction-limited part </span>
        <span class="n">imdim</span>      <span class="o">+=</span> <span class="mf">2.44</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">referenceWavelength</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">aperture</span>
        <span class="c"># Calculates the solid angle &quot;seen&quot; by the points</span>
        <span class="k">if</span> <span class="n">skipPupilAngle</span><span class="p">:</span>
            <span class="n">pupilSolidAngle</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pupilSolidAngle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">virtualApertureArea</span> <span class="o">/</span> <span class="n">w</span><span class="o">**</span><span class="mi">2</span>
        
<span class="c">#        print &quot;W&quot;, np.min(w), np.median(w), np.mean(w), np.max(w)</span>
<span class="c">#        print &quot;imdim&quot;, np.min(imdim), np.median(imdim), np.mean(imdim), np.max(imdim)</span>
<span class="c">#        print &quot;F&quot;, self.lens.F</span>
<span class="c">#        print &quot;p&#39;&quot;, np.min(pprime), np.median(pprime), np.mean(pprime), np.max(pprime)</span>
<span class="c">#        print &quot;p&quot;, np.min(p), np.median(p), np.mean(p), np.max(p)</span>
<span class="c">#        print &quot;H&#39;S&quot;, HpS</span>
<span class="c">#        print &quot;H&#39;X&quot;, HpX </span>
        
        <span class="k">return</span> <span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">duvw</span><span class="p">,</span> <span class="n">lineofsight</span><span class="p">,</span> <span class="n">imdim</span><span class="p">,</span> <span class="n">pupilSolidAngle</span><span class="p">)</span>    
        </div>
    <span class="k">def</span> <span class="nf">_shootRays</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                  <span class="n">sensorParamCoords</span><span class="p">,</span>
                  <span class="n">maximumRayTrace</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
                  <span class="n">restart</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is a convenience method to create a ray bundle departing from the</span>
<span class="sd">        fore pinhole (the center of the entrance pupil) to be used in ray </span>
<span class="sd">        tracing.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sensorParamCoords : numpy.array (N,2)</span>
<span class="sd">            The UV coordinates of the point in the sensor originating the rays</span>
<span class="sd">        maximumRayTrace : float</span>
<span class="sd">            The maximum distance for the ray to be traced</span>
<span class="sd">        restart : boolean (False)</span>
<span class="sd">            If the previous tracing needs to be continued, setting this flag</span>
<span class="sd">            to True will make the process continue from its last point </span>
<span class="sd">            (don&#39;t forget to increase maximumRayTrace, which refers to the total</span>
<span class="sd">            distance travelled by the ray, including from previous runs)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">restart</span><span class="p">:</span>
            <span class="n">sensorCoords</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">parametricToPhysical</span><span class="p">(</span><span class="n">sensorParamCoords</span><span class="p">)</span>
            <span class="c"># Creates vectors to initialize ray tracing for each point in the </span>
            <span class="c"># sensor </span>
            <span class="n">initialVectors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">rayVector</span><span class="p">(</span><span class="n">sensorCoords</span><span class="p">)</span>
            <span class="n">bundle</span>         <span class="o">=</span> <span class="n">Primitives</span><span class="o">.</span><span class="n">RayBundle</span><span class="p">()</span>
            <span class="n">bundle</span><span class="o">.</span><span class="n">name</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s">&quot;RayTracingBundle&quot;</span>
            <span class="n">bundle</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">initialVectors</span><span class="p">,</span> 
                          <span class="bp">self</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">PinholeFore</span><span class="p">,</span> 
                          <span class="bp">self</span><span class="o">.</span><span class="n">referenceWavelength</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">bundle</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="k">pass</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bundle</span><span class="p">)</span>               

        <span class="n">bundle</span><span class="o">.</span><span class="n">maximumRayTrace</span>   <span class="o">=</span> <span class="n">maximumRayTrace</span>
        <span class="n">bundle</span><span class="o">.</span><span class="n">stepRayTrace</span>      <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">maximumRayTrace</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">bundle</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">tracingRule</span> <span class="o">=</span> <span class="n">Primitives</span><span class="o">.</span><span class="n">RayBundle</span><span class="o">.</span><span class="n">TRACING_FOV</span><span class="p">,</span>
                            <span class="n">restart</span>     <span class="o">=</span> <span class="n">restart</span><span class="p">)</span> 
        <span class="k">return</span> <span class="n">bundle</span>
        
    <span class="k">def</span> <span class="nf">_calculateMappings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method calculates the transformation matrix(ces) to go from</span>
<span class="sd">        world coordinates (XYZ) to parametric sensor coordinates (UV). This is</span>
<span class="sd">        a method to avoid having to do ray tracing for each particle, when</span>
<span class="sd">        generating a synthetic PIV image, for example.</span>
<span class="sd">        </span>
<span class="sd">        The field of view is mapped using a volume (target), and it is assumed</span>
<span class="sd">        that the light path is rectilinear inside it. The field of view is</span>
<span class="sd">        discretized in MxN regions, as defined in the mappingResolution </span>
<span class="sd">        property of the camera.</span>
<span class="sd">        </span>
<span class="sd">        Discretization in more than one volume is only needed in cases where</span>
<span class="sd">        the pinhole camera model is not valid, e.g. in the presence of radial</span>
<span class="sd">        distortions or refractive elements. In theory any mapping is represented</span>
<span class="sd">        in a piecewise linear manner using the domain partition, however this</span>
<span class="sd">        makes computation of synthetic images much more expensive.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># First determine the points in the sensor to be reference for the</span>
        <span class="c"># mapping</span>
        <span class="p">[</span><span class="n">U</span><span class="p">,</span><span class="n">V</span><span class="p">]</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">mappingResolution</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> 
                             <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">mappingResolution</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> 
<span class="c">#        print V</span>
<span class="c">#        print U   </span>
        <span class="n">parametricCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">U</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">V</span><span class="o">.</span><span class="n">ravel</span><span class="p">()])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">UV</span>               <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">parametricCoords</span><span class="p">,</span> 
                                      <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">U</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">U</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="mi">2</span><span class="p">))</span>
<span class="c">#        print UV</span>
        <span class="n">bundle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shootRays</span><span class="p">(</span><span class="n">parametricCoords</span><span class="p">,</span>
                                <span class="n">maximumRayTrace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">focusingDistance</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
<span class="c">#        self += bundle</span>
<span class="c">#        self += target</span>
<span class="c">#        import System</span>
<span class="c">#        System.plot(self)</span>

        <span class="c"># Finds the intersections that are important:</span>
        <span class="n">intersections</span> <span class="o">=</span> <span class="p">(</span><span class="n">target</span> <span class="o">==</span> <span class="n">bundle</span><span class="o">.</span><span class="n">rayIntersections</span><span class="p">)</span>
        <span class="c"># Finds first and last points</span>
        <span class="n">intersections</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">intersections</span><span class="p">,</span><span class="n">GLOBAL_NDIM</span><span class="p">)</span>
        <span class="n">firstInts</span>       <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">bundle</span><span class="o">.</span><span class="n">rayPaths</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">lastInts</span>        <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">bundle</span><span class="o">.</span><span class="n">rayPaths</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">mask</span>            <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">bundle</span><span class="o">.</span><span class="n">rayPaths</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">bundle</span><span class="o">.</span><span class="n">rayPaths</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
            <span class="n">firstInts</span><span class="p">[</span><span class="n">mask</span> <span class="o">*</span> <span class="n">intersections</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> \
                        <span class="n">bundle</span><span class="o">.</span><span class="n">rayPaths</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">mask</span> <span class="o">*</span> <span class="n">intersections</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
                        
            <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">intersections</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
            
            <span class="n">lastInts</span><span class="p">[</span><span class="n">intersections</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span>  \
                        <span class="n">bundle</span><span class="o">.</span><span class="n">rayPaths</span><span class="p">[</span><span class="n">n</span><span class="p">,</span><span class="n">intersections</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
        
        <span class="n">bundle</span> <span class="o">=</span> <span class="bp">None</span>
        
        <span class="n">firstInts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">firstInts</span><span class="p">,</span> 
                               <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">U</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">U</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">GLOBAL_NDIM</span><span class="p">))</span>
        <span class="n">lastInts</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">lastInts</span><span class="p">,</span> 
                               <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">U</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">U</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">GLOBAL_NDIM</span><span class="p">))</span>  
<span class="c">#        print UV</span>
<span class="c">#        print firstInts</span>
<span class="c">#        print lastInts      </span>
        
        <span class="n">XYZ</span>   <span class="o">=</span> <span class="p">(</span><span class="n">firstInts</span> <span class="o">+</span> <span class="n">lastInts</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sensorSamplingCenters</span>    <span class="o">=</span> <span class="p">(</span><span class="n">UV</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="o">+</span> <span class="n">UV</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:]</span>  <span class="o">+</span>
                                         <span class="n">UV</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span><span class="mi">1</span><span class="p">:]</span>  <span class="o">+</span> <span class="n">UV</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mi">4</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">physicalSamplingCenters</span>  <span class="o">=</span> <span class="p">(</span><span class="n">XYZ</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">XYZ</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span>
                                         <span class="n">XYZ</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span><span class="mi">1</span><span class="p">:]</span>   <span class="o">+</span> <span class="n">XYZ</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mi">4</span>
                   
        <span class="bp">self</span><span class="o">.</span><span class="n">mapping</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">UV</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">UV</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                                    <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="c">#each mapping matrix is 3x4</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">detmapping</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">UV</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">UV</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="c">#determinants are scalar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dmapping</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">UV</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                                   <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">UV</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                                   <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="c">#each derivative matrix is 6x3</span>

        <span class="n">cond</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensorSamplingCenters</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensorSamplingCenters</span><span class="p">,</span><span class="mi">1</span><span class="p">)):</span>
                <span class="n">uvlist</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">UV</span><span class="p">[</span><span class="n">i</span>  <span class="p">,</span><span class="n">j</span>  <span class="p">],</span>
                                    <span class="n">UV</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span>  <span class="p">],</span>
                                    <span class="n">UV</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span>
                                    <span class="n">UV</span><span class="p">[</span><span class="n">i</span>  <span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span>
                                    <span class="n">UV</span><span class="p">[</span><span class="n">i</span>  <span class="p">,</span><span class="n">j</span>  <span class="p">],</span>
                                    <span class="n">UV</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span>  <span class="p">],</span>
                                    <span class="n">UV</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span>
                                    <span class="n">UV</span><span class="p">[</span><span class="n">i</span>  <span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]])</span>
                <span class="c"># We want the DLT to be from meters to meters:</span>
                <span class="n">uvlist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">parametricToSensor</span><span class="p">(</span><span class="n">uvlist</span><span class="p">)</span>
                
                <span class="n">xyzlist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">firstInts</span><span class="p">[</span><span class="n">i</span>  <span class="p">,</span><span class="n">j</span>  <span class="p">],</span>
                                    <span class="n">firstInts</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span>  <span class="p">],</span>
                                    <span class="n">firstInts</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span>
                                    <span class="n">firstInts</span><span class="p">[</span><span class="n">i</span>  <span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span>
                                    <span class="n">lastInts</span><span class="p">[</span><span class="n">i</span>  <span class="p">,</span><span class="n">j</span>  <span class="p">],</span>
                                    <span class="n">lastInts</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span>  <span class="p">],</span>
                                    <span class="n">lastInts</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span>
                                    <span class="n">lastInts</span><span class="p">[</span><span class="n">i</span>  <span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]])</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mapping</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:,:],</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">dmapping</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:,:],</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">detmapping</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">],</span>
                     <span class="n">temp1</span><span class="p">,</span>
                     <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">Utils</span><span class="o">.</span><span class="n">DLT</span><span class="p">(</span><span class="n">uvlist</span><span class="p">,</span><span class="n">xyzlist</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mapping</span>    <span class="o">=</span> <span class="bp">None</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">detmapping</span> <span class="o">=</span> <span class="bp">None</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dmapping</span>   <span class="o">=</span> <span class="bp">None</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Could not find a valid mapping&quot;</span><span class="p">,</span> <span class="ne">Warning</span><span class="p">)</span>
                    <span class="k">return</span>
                <span class="n">cond</span> <span class="o">=</span> <span class="n">cond</span> <span class="o">+</span> <span class="n">temp1</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">cond</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensorSamplingCenters</span><span class="p">)</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cond</span>
    
<div class="viewcode-block" id="Camera.initialize"><a class="viewcode-back" href="../../Camera.html#pyvsim.Toolbox.Camera.initialize">[docs]</a>    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function calculates the camera field of view and its mapping</span>
<span class="sd">        functions to relate world coordinates to sensor coordinates. This</span>
<span class="sd">        should be called whenever the ambient is set up, so the camera can </span>
<span class="sd">        be used for synthetic image generation and displaying.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vv</span><span class="p">,</span><span class="n">vh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_depthOfField</span><span class="p">()</span>
        <span class="c"># Make sure rays intersect volume by expanding it a little</span>
        <span class="n">vv</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mf">0.005</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">+=</span> <span class="n">vv</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calculateMappings</span><span class="p">(</span><span class="n">vv</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">vv</span><span class="p">)</span>
        
        <span class="c"># Determines the distance mapped by the DLT for the points, so that</span>
        <span class="c"># the solid angle can be calculated individually for each particle.</span>
        <span class="c"># Only vh is used, assuming that astigmatism is not high</span>
        <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapPoints</span><span class="p">(</span><span class="n">vh</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">skipPupilAngle</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">virtualApertureArea</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">vh</span><span class="o">.</span><span class="n">data</span> <span class="o">*</span> <span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        
    </div>
    <span class="k">def</span> <span class="nf">_depthOfField</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method calculates the camera field of view and depth of field.</span>
<span class="sd">        Two volumes are returned - one for vertical focusing and another for</span>
<span class="sd">        horizontal focusing (when the ambient has no refractive elements, both</span>
<span class="sd">        will probably be the same).</span>
<span class="sd">                </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        (VV, VH) : pyvsim.Volume</span>
<span class="sd">            Each of the volumes represent the region where a point is imaged</span>
<span class="sd">            by the camera as a feature with a diameter no greater than </span>
<span class="sd">            &quot;allowableDiameter&quot;. Only in the case of astigmatism, VV and VH</span>
<span class="sd">            are not the same, then VV (vertical) is the volume where the point </span>
<span class="sd">            is in focus at the camera.y axis and VH (horizontal) is in focus</span>
<span class="sd">            at the camera.z axis </span>
<span class="sd">            One important point is that the field .data of the volumes has the</span>
<span class="sd">            solid angle formed by the entrance pupil image as &quot;seen&quot; by the</span>
<span class="sd">            particle. This is used in scattering calculations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">points_param</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                  <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span>
                                  <span class="p">[</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span>
                                  <span class="p">[</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">points</span>        <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">parametricToPhysical</span><span class="p">(</span><span class="n">points_param</span><span class="p">)</span>
        
        <span class="n">X</span>             <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">Xdim</span>
        <span class="n">HprimeX</span>       <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">H_aft_scalar</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">X_scalar</span>
        <span class="n">dcoc</span>          <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">circleOfConfusionDiameter</span>
        <span class="c"># The distance between sensor extremities and center of fore main</span>
        <span class="c"># plane, projected at the lens optical axis</span>
        <span class="n">points_proj</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">H_aft</span> <span class="o">-</span> <span class="n">points</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">x</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="n">p_prime_fore</span>  <span class="o">=</span> <span class="p">(</span><span class="n">X</span><span class="o">*</span><span class="n">points_proj</span> <span class="o">+</span> <span class="n">dcoc</span><span class="o">*</span><span class="n">HprimeX</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">X</span> <span class="o">+</span> <span class="n">dcoc</span><span class="p">)</span>
        <span class="n">p_prime_aft</span>   <span class="o">=</span> <span class="p">(</span><span class="n">X</span><span class="o">*</span><span class="n">points_proj</span> <span class="o">-</span> <span class="n">dcoc</span><span class="o">*</span><span class="n">HprimeX</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">X</span> <span class="o">-</span> <span class="n">dcoc</span><span class="p">)</span>
<span class="c">#        p_prime_spot  = points_proj</span>
        
        <span class="n">p_fore</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">F</span><span class="o">*</span><span class="n">p_prime_fore</span> <span class="o">/</span> <span class="p">(</span><span class="n">p_prime_fore</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">F</span><span class="p">)</span>
        <span class="n">p_aft</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">F</span><span class="o">*</span><span class="n">p_prime_aft</span>  <span class="o">/</span> <span class="p">(</span><span class="n">p_prime_aft</span>  <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">F</span><span class="p">)</span>
<span class="c">#        p_spot = self.lens.F*p_prime_spot / (p_prime_spot - self.lens.F)</span>
        
        <span class="sd">&quot;&quot;&quot; Find the vectors emerging from the lens: &quot;&quot;&quot;</span>
<span class="c">#        print &quot;=--------------------- DOF CALC --------------------------&quot;</span>
<span class="c">#        print &quot;pts\n&quot;, points</span>
<span class="c">#        print &quot;H &quot;, self.lens.H_fore</span>
<span class="c">#        print &quot;H&#39;&quot;, self.lens.H_aft</span>
<span class="c">#        print &quot;E &quot;, self.lens.E</span>
<span class="c">#        print &quot;X &quot;, self.lens.X</span>
<span class="c">#        print &quot;d&#39;&quot;, self.lens.focusingOffset</span>
<span class="c">#        print &quot;fl&quot;, self.lens.origin</span>
<span class="c">#        print &quot;ph_aft &quot;, self.lens.PinholeAft</span>
<span class="c">#        print &quot;ph_fore&quot;, self.lens.PinholeFore</span>
<span class="c">#        print &quot;p_fore\n&quot;, p_fore</span>
<span class="c">#        print &quot;p_aft\n&quot;,  p_aft</span>
<span class="c">#        print &quot;p_spot\n&quot;, p_spot</span>

        <span class="n">vecs</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">rayVector</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="n">vecx</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">vecs</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c"># projection at optical axis</span>

        <span class="n">p_fore</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">H_fore_scalar</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">E_scalar</span> 
        <span class="n">p_aft</span>  <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">H_fore_scalar</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">E_scalar</span>  
<span class="c">#        p_spot += self.lens.H_fore_scalar - self.lens.E_scalar  </span>

        <span class="c"># &quot;Elongate&quot; points to adapt to ray tracing</span>
        <span class="n">p_fore</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&quot;i,ij-&gt;ij&quot;</span><span class="p">,</span> <span class="n">p_fore</span> <span class="o">*</span> <span class="mi">1</span><span class="o">/</span><span class="n">vecx</span><span class="p">,</span><span class="n">vecs</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">E</span>
        <span class="n">p_aft</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&quot;i,ij-&gt;ij&quot;</span><span class="p">,</span> <span class="n">p_aft</span>  <span class="o">*</span> <span class="mi">1</span><span class="o">/</span><span class="n">vecx</span><span class="p">,</span><span class="n">vecs</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">E</span>
<span class="c">#        p_spot = np.einsum(&quot;i,ij-&gt;ij&quot;, p_spot * 1/vecx,vecs) + self.lens.E</span>

        <span class="sd">&quot;&quot;&quot; p_fore and p_aft are the points in space limiting the in-focus</span>
<span class="sd">        region, were there no obstructions, reflection, etc &quot;&quot;&quot;</span>
        
        <span class="n">p_fore_horz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">p_fore</span><span class="p">)</span>
        <span class="n">p_fore_vert</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">p_fore</span><span class="p">)</span>
        <span class="n">p_aft_horz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">p_aft</span><span class="p">)</span>
        <span class="n">p_aft_vert</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">p_aft</span><span class="p">)</span>
        <span class="n">vv_angles</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
        <span class="n">vh_angles</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">p_fore</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
            <span class="p">(</span><span class="n">pts</span><span class="p">,</span> <span class="n">ang</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_findFocusingPoint</span><span class="p">(</span><span class="n">p_fore</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
            <span class="n">p_fore_vert</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">p_fore_horz</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> 
            <span class="n">vv_angles</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">ang</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">vh_angles</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">ang</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">(</span><span class="n">pts</span><span class="p">,</span> <span class="n">ang</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_findFocusingPoint</span><span class="p">(</span><span class="n">p_aft</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
            <span class="n">p_aft_vert</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">p_aft_horz</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">vv_angles</span><span class="p">[</span><span class="mi">4</span><span class="o">+</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">ang</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">vh_angles</span><span class="p">[</span><span class="mi">4</span><span class="o">+</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">ang</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        
        <span class="c"># Remove duplicates (in case calculation has already been done)        </span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s">&quot;In-focus-vertical&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">pass</span>
        
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s">&quot;In-focus-horizontal&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">pass</span>
                
        <span class="n">volume_vert</span>                 <span class="o">=</span> <span class="n">Primitives</span><span class="o">.</span><span class="n">Volume</span><span class="p">()</span>
        <span class="n">volume_vert</span><span class="o">.</span><span class="n">surfaceProperty</span> <span class="o">=</span> <span class="n">volume_vert</span><span class="o">.</span><span class="n">TRANSPARENT</span>
        <span class="n">volume_vert</span><span class="o">.</span><span class="n">name</span>            <span class="o">=</span> <span class="s">&quot;In-focus-vertical&quot;</span>
        <span class="n">volume_vert</span><span class="o">.</span><span class="n">color</span>           <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">volume_vert</span><span class="o">.</span><span class="n">opacity</span>         <span class="o">=</span> <span class="mf">0.25</span>
        <span class="n">volume_vert</span><span class="o">.</span><span class="n">points</span>          <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">p_aft_vert</span><span class="p">,</span><span class="n">p_fore_vert</span><span class="p">])</span>
        <span class="n">volume_vert</span><span class="o">.</span><span class="n">data</span>            <span class="o">=</span> <span class="n">vv_angles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">volume_vert</span><span class="p">)</span>
        
        <span class="n">volume_horz</span>                 <span class="o">=</span> <span class="n">Primitives</span><span class="o">.</span><span class="n">Volume</span><span class="p">()</span>
        <span class="n">volume_horz</span><span class="o">.</span><span class="n">surfaceProperty</span> <span class="o">=</span> <span class="n">volume_horz</span><span class="o">.</span><span class="n">TRANSPARENT</span>
        <span class="n">volume_horz</span><span class="o">.</span><span class="n">name</span>            <span class="o">=</span> <span class="s">&quot;In-focus-horizontal&quot;</span>
        <span class="n">volume_horz</span><span class="o">.</span><span class="n">color</span>           <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="c">#np.array(Utils.metersToRGB(referenceWavelength))</span>
        <span class="n">volume_horz</span><span class="o">.</span><span class="n">opacity</span>         <span class="o">=</span> <span class="mf">0.25</span>
        <span class="n">volume_horz</span><span class="o">.</span><span class="n">points</span>          <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">p_aft_horz</span><span class="p">,</span><span class="n">p_fore_horz</span><span class="p">])</span>
        <span class="n">volume_horz</span><span class="o">.</span><span class="n">data</span>            <span class="o">=</span> <span class="n">vh_angles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">volume_horz</span><span class="p">)</span>        
        
        <span class="bp">self</span><span class="o">.</span><span class="n">rawPupilSolidAngle</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">vv_angles</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">vh_angles</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">volume_vert</span><span class="p">,</span> <span class="n">volume_horz</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">_findFocusingPoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                           <span class="n">theoreticalPoint</span><span class="p">,</span>
                           <span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">90</span><span class="p">]),</span> 
                           <span class="n">tol</span> <span class="o">=</span> <span class="mf">1e-3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        As the environment that the camera is placed can include mirrors</span>
<span class="sd">        and refractive materials, the light path has to be calculated with </span>
<span class="sd">        the ray tracing algorithm.</span>
<span class="sd">        </span>
<span class="sd">        For the given point, four rays are cast - each at a border of the</span>
<span class="sd">        entrance pupil. Their initial vector is defined as the one that reaches</span>
<span class="sd">        the theoretical point (given).</span>
<span class="sd">        </span>
<span class="sd">        Then, for each pair (the horizontal and the vertical), the </span>
<span class="sd">        intersection of the ray paths is verified. The intersection point is</span>
<span class="sd">        then the point in space where focusing is perfect.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        theoreticalPoint : numpy.array (3)</span>
<span class="sd">            This is the point in space where the camera would be imaging if it</span>
<span class="sd">            were isolated (no mirrors, refractions, etc)</span>
<span class="sd">        angles : numpy.array (N) [0, 90]</span>
<span class="sd">            The angles (with relation to the optical axis) for analysis of </span>
<span class="sd">            astigmatism in the system. The typical configuration performs the</span>
<span class="sd">            analysis only on the lens xy and xz planes, respectively.         </span>
<span class="sd">        tol : float (1e-3)</span>
<span class="sd">            The tolerance in finding the ray intersection. This value is kept</span>
<span class="sd">            relatively high because in the case of astigmatism, the Y and Z</span>
<span class="sd">            axes of the camera might not be aligned with the astigmatism axes,</span>
<span class="sd">            which can cause the intersection not to be perfect. This value</span>
<span class="sd">            still produces results comparable to the one found in Zeiss </span>
<span class="sd">            datasheets</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pts : numpy.array (N,3)</span>
<span class="sd">            Each point is the intersection of the marginal rays casted from</span>
<span class="sd">            the intersection of the entrance pupil and a plane at an angle</span>
<span class="sd">            determined by the parameter &quot;angle&quot; in the input. </span>
<span class="sd">        angle : numpy.array (N)</span>
<span class="sd">            The solid angle formed by the point and the entrance pupil</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pupilPoints</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">),</span><span class="mi">3</span><span class="p">))</span>
        <span class="n">pupilPoints</span>   <span class="o">=</span> <span class="n">pupilPoints</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">E</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">angle</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">angles</span><span class="p">):</span>
            <span class="n">angle</span> <span class="o">=</span> <span class="n">angle</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span>
            <span class="n">pupilPoints</span><span class="p">[</span><span class="n">n</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span>   <span class="o">=</span> <span class="p">(</span><span class="n">pupilPoints</span><span class="p">[</span><span class="n">n</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> 
                                  <span class="bp">self</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">z</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">Edim</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">Edim</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">pupilPoints</span><span class="p">[</span><span class="n">n</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">pupilPoints</span><span class="p">[</span><span class="n">n</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">z</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">Edim</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">Edim</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>

<span class="c">#        print &quot;Entrance pupil\n&quot;, pupilPoints</span>
        <span class="sd">&quot;&quot;&quot; Vectors going to the theoretical point &quot;&quot;&quot;</span>
        <span class="n">vectors</span>       <span class="o">=</span> <span class="n">Utils</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">theoreticalPoint</span> <span class="o">-</span> <span class="n">pupilPoints</span><span class="p">)</span>
        
<span class="c">#        print &quot;Vectors\n&quot;, vectors</span>
<span class="c">#        print &quot;Vecnorms\n&quot;, np.sqrt(np.sum(vectors*vectors,1))</span>
        <span class="sd">&quot;&quot;&quot; Create the bundle for ray tracing &quot;&quot;&quot;</span>
        <span class="n">rays</span>                 <span class="o">=</span> <span class="n">Primitives</span><span class="o">.</span><span class="n">RayBundle</span><span class="p">()</span>
        <span class="n">n</span>                    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rays</span><span class="p">)</span>
        <span class="n">rays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vectors</span><span class="p">,</span> <span class="n">pupilPoints</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">referenceWavelength</span><span class="p">)</span>
        <span class="n">rays</span><span class="o">.</span><span class="n">maximumRayTrace</span> <span class="o">=</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">Utils</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">theoreticalPoint</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">E</span><span class="p">)</span>
        <span class="n">rays</span><span class="o">.</span><span class="n">stepRayTrace</span>    <span class="o">=</span> <span class="n">rays</span><span class="o">.</span><span class="n">maximumRayTrace</span>
        <span class="n">rays</span><span class="o">.</span><span class="n">trace</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="sd">&quot;&quot;&quot; Now run the bundle trying to find the intersection &quot;&quot;&quot;</span>
        <span class="n">steps</span>        <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">rays</span><span class="o">.</span><span class="n">rayPaths</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">pts</span>          <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">),</span><span class="mi">3</span><span class="p">))</span>
        <span class="n">pupil_angle</span>  <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">steps</span><span class="p">):</span>
            <span class="n">p2</span>   <span class="o">=</span> <span class="n">rays</span><span class="o">.</span><span class="n">rayPaths</span><span class="p">[</span><span class="n">step</span><span class="p">]</span>
            <span class="n">p1</span>   <span class="o">=</span> <span class="n">rays</span><span class="o">.</span><span class="n">rayPaths</span><span class="p">[</span><span class="n">step</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">v</span>    <span class="o">=</span> <span class="n">p2</span> <span class="o">-</span> <span class="n">p1</span>
            
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)):</span>
                <span class="n">point</span> <span class="o">=</span> <span class="n">Utils</span><span class="o">.</span><span class="n">linesIntersection</span><span class="p">(</span><span class="n">v</span> <span class="p">[[</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span> 
                                                <span class="n">p1</span><span class="p">[[</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]])</span> 

                <span class="k">if</span> <span class="p">(</span><span class="n">Utils</span><span class="o">.</span><span class="n">pointSegmentDistance</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">point</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                    <span class="n">pts</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">point</span>
                    <span class="n">planar_angle</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">],</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span>
                                               <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">])</span><span class="o">*</span>
                                                <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">])))</span>
                    <span class="n">pupil_angle</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">planar_angle</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="c">#                    print &quot;Angle %3.4f, angle %3.4f, solid angle %1.4e&quot; % (angles[n], </span>
<span class="c">#                                                                           planar_angle*180/np.pi, </span>
<span class="c">#                                                                           pupil_angle[n])</span>
        <span class="n">rays</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">pts</span><span class="p">,</span> <span class="n">pupil_angle</span><span class="p">)</span>
    
<div class="viewcode-block" id="Camera.virtualCameras"><a class="viewcode-back" href="../../Camera.html#pyvsim.Toolbox.Camera.virtualCameras">[docs]</a>    <span class="k">def</span> <span class="nf">virtualCameras</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">centeronly</span> <span class="o">=</span> <span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an assembly composed of cameras at the position and orientation</span>
<span class="sd">        defined by the original camera mapping. E.g. if a camera is looking</span>
<span class="sd">        through a mirror, the virtualCamera will be the mirror image of the</span>
<span class="sd">        camera.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        centeronly : boolean</span>
<span class="sd">            If the camera mapping resolution has created more than a single </span>
<span class="sd">            mapping matrix (&gt;2), setting this value to True makes the routine</span>
<span class="sd">            create only one camera (for the center mapping). Otherwise it will</span>
<span class="sd">            create as many cameras as mapping matrices.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        virtualCameras : pyvsim.Assembly</span>
<span class="sd">            The cameras within this assembly are copies of the original camera</span>
<span class="sd">            only with position and orientation changed (and carcass color), so</span>
<span class="sd">            they are completely functional.</span>
<span class="sd">            Care should be taken, as having too many cameras requires a lot of</span>
<span class="sd">            memory (mappings, sensor data is stored in each camera).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapping</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span>  <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;No mapping available, &quot;</span> <span class="o">+</span>
                              <span class="s">&quot;could not create virtual cameras&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="n">phantomPrototype</span>                    <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">phantomPrototype</span><span class="o">.</span><span class="n">clearData</span><span class="p">()</span>
        <span class="n">phantomPrototype</span><span class="o">.</span><span class="n">parent</span>             <span class="o">=</span> <span class="bp">None</span>
        <span class="n">phantomPrototype</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">color</span>         <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">phantomPrototype</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">opacity</span>       <span class="o">=</span> <span class="mf">0.2</span>
        <span class="n">phantomPrototype</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">color</span>         <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">]</span>
        <span class="n">phantomPrototype</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">opacity</span>       <span class="o">=</span> <span class="mf">0.2</span>
<span class="c">#        print phantomPrototype.x</span>
<span class="c">#        print phantomPrototype.y</span>
<span class="c">#        print phantomPrototype.z</span>
<span class="c">#        print phantomPrototype.lens.x</span>
<span class="c">#        print phantomPrototype.lens.y</span>
<span class="c">#        print phantomPrototype.lens.z</span>
        <span class="n">phantomPrototype</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">alignTo</span><span class="p">(</span><span class="n">phantomPrototype</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">phantomPrototype</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">phantomPrototype</span><span class="p">:</span>
            <span class="n">item</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">phantomPrototype</span>

        <span class="n">phantomAssembly</span>                     <span class="o">=</span> <span class="n">Primitives</span><span class="o">.</span><span class="n">Assembly</span><span class="p">()</span>
<span class="c">#        sy                                  = self.sensor.dimension[1]</span>
<span class="c">#        sz                                  = self.sensor.dimension[2]</span>
        <span class="c"># Matrix to go from sensor coordinates to sensor</span>
        <span class="c"># local coordinates</span>
        <span class="n">MT</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="mi">0</span>  <span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">],</span>
                        <span class="p">[</span> <span class="mi">0</span>  <span class="p">,</span>   <span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">],</span>
                        <span class="p">[</span> <span class="mi">1</span>  <span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">]])</span>

        <span class="k">if</span> <span class="n">centeronly</span><span class="p">:</span>
            <span class="n">rangei</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mapping</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)]</span>
            <span class="n">rangej</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mapping</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rangei</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mapping</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
            <span class="n">rangej</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mapping</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
            
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rangei</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">rangej</span><span class="p">:</span>
                <span class="n">phantom</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">phantomPrototype</span><span class="p">)</span>
                <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapping</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:,:]</span>
                <span class="p">[</span><span class="n">_</span><span class="p">,</span><span class="n">__</span><span class="p">,</span><span class="n">V</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>                             
                <span class="n">pinholePosition</span> <span class="o">=</span> <span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">V</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">])[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">phantom</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">pinholePosition</span> <span class="o">-</span> 
                                  <span class="n">phantom</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">PinholeFore</span><span class="p">)</span>

                <span class="c"># Transform the DLT matrix (that originally goes from global</span>
                <span class="c"># coordinates to sensor coords) to local sensor coordinates</span>
                <span class="n">MTM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">MT</span><span class="p">,</span> <span class="n">M</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="p">[</span><span class="n">_</span><span class="p">,</span><span class="n">Qm</span><span class="p">]</span> <span class="o">=</span> <span class="n">Utils</span><span class="o">.</span><span class="n">KQ</span><span class="p">(</span><span class="n">MTM</span><span class="p">)</span>
                    
                <span class="n">phantom</span><span class="o">.</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">M</span>
                <span class="n">phantom</span><span class="o">.</span><span class="n">alignTo</span><span class="p">(</span><span class="n">Qm</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="o">-</span><span class="n">Qm</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="bp">None</span><span class="p">,</span>
                                <span class="n">phantom</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">PinholeFore</span><span class="p">,</span> <span class="mf">1e-3</span><span class="p">)</span> 
                <span class="n">phantomAssembly</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">phantom</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">phantomAssembly</span>
         </div></div>
<div class="viewcode-block" id="Seeding"><a class="viewcode-back" href="../../Seeding.html#pyvsim.Toolbox.Seeding">[docs]</a><span class="k">class</span> <span class="nc">Seeding</span><span class="p">(</span><span class="n">Primitives</span><span class="o">.</span><span class="n">Assembly</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">Primitives</span><span class="o">.</span><span class="n">Assembly</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span>                   <span class="o">=</span> <span class="s">&#39;Seeding &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">volume</span>                 <span class="o">=</span> <span class="n">Primitives</span><span class="o">.</span><span class="n">Volume</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cloud</span>                  <span class="o">=</span> <span class="n">Primitives</span><span class="o">.</span><span class="n">Points</span><span class="p">()</span>
        <span class="bp">self</span>                       <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">volume</span>
        <span class="bp">self</span>                       <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cloud</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">density</span>                <span class="o">=</span> <span class="mf">1e11</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_particles</span>             <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_diameters</span>             <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="o">.</span><span class="n">color</span>           <span class="o">=</span> <span class="p">[</span><span class="mf">0.9</span><span class="p">,</span><span class="mf">0.9</span><span class="p">,</span><span class="mf">0.9</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="o">.</span><span class="n">surfaceProperty</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="o">.</span><span class="n">TRANSPARENT</span>
        
<div class="viewcode-block" id="Seeding.refractiveIndex"><a class="viewcode-back" href="../../Seeding.html#pyvsim.Toolbox.Seeding.refractiveIndex">[docs]</a>    <span class="k">def</span> <span class="nf">refractiveIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wavelength</span> <span class="o">=</span> <span class="mf">532e-9</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the index of refraction of the material given the wavelength</span>
<span class="sd">        (or a list of them)</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        wavelength : scalar or numpy.array</span>
<span class="sd">            The wavelength of the incoming light given in *meters*</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        refractiveIndex : same dimension as wavelength</span>
<span class="sd">            The index of refraction</span>
<span class="sd">        &quot;&quot;&quot;</span>       
        <span class="k">return</span> <span class="mf">1.45386</span> <span class="c">#self.material.refractiveIndex(wavelength)</span>
        </div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="Seeding.bounds"><a class="viewcode-back" href="../../Seeding.html#pyvsim.Toolbox.Seeding.bounds">[docs]</a>    <span class="k">def</span> <span class="nf">bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This signals the ray tracing implementation that no attempt should be</span>
<span class="sd">        made to intersect rays with the seeding (it&#39;s mapped differently)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">None</span>
            </div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cloud</span><span class="o">.</span><span class="n">points</span>
    <span class="nd">@points.setter</span>
    <span class="k">def</span> <span class="nf">points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">particles</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cloud</span><span class="o">.</span><span class="n">points</span>  <span class="o">=</span> <span class="n">particles</span>
        <span class="p">[</span><span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">zmin</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">particles</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="p">[</span><span class="n">xmax</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">zmax</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">particles</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">xmin</span><span class="p">,</span><span class="n">ymax</span><span class="p">,</span><span class="n">zmax</span><span class="p">],</span>
                                       <span class="p">[</span><span class="n">xmin</span><span class="p">,</span><span class="n">ymin</span><span class="p">,</span><span class="n">zmax</span><span class="p">],</span>
                                       <span class="p">[</span><span class="n">xmin</span><span class="p">,</span><span class="n">ymin</span><span class="p">,</span><span class="n">zmin</span><span class="p">],</span>
                                       <span class="p">[</span><span class="n">xmin</span><span class="p">,</span><span class="n">ymax</span><span class="p">,</span><span class="n">zmin</span><span class="p">],</span>
                                       <span class="p">[</span><span class="n">xmax</span><span class="p">,</span><span class="n">ymax</span><span class="p">,</span><span class="n">zmax</span><span class="p">],</span>
                                       <span class="p">[</span><span class="n">xmax</span><span class="p">,</span><span class="n">ymin</span><span class="p">,</span><span class="n">zmax</span><span class="p">],</span>
                                       <span class="p">[</span><span class="n">xmax</span><span class="p">,</span><span class="n">ymin</span><span class="p">,</span><span class="n">zmin</span><span class="p">],</span>
                                       <span class="p">[</span><span class="n">xmax</span><span class="p">,</span><span class="n">ymax</span><span class="p">,</span><span class="n">zmin</span><span class="p">]])</span>
                
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">diameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_diameters</span>
    <span class="nd">@diameters.setter</span>
    <span class="k">def</span> <span class="nf">diameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">diams</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">diams</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cloud</span><span class="o">.</span><span class="n">points</span><span class="p">,</span><span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;The diameter array must be the same size than&quot;</span><span class="o">+</span>
                             <span class="s">&quot; the particle position array.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_diameters</span> <span class="o">=</span> <span class="n">diams</span>
            
    <span class="k">def</span> <span class="nf">seed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">o</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">v1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">v2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">v3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> 
        <span class="n">volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span><span class="n">v3</span><span class="p">)))</span>
        <span class="n">npts</span>   <span class="o">=</span> <span class="n">volume</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">density</span>
        <span class="n">pts</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">npts</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">pts</span>    <span class="o">=</span> <span class="n">o</span> <span class="o">+</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&quot;i,j-&gt;ij&quot;</span><span class="p">,</span><span class="n">pts</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">v1</span><span class="p">)</span> <span class="o">+</span>   
                      <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&quot;i,j-&gt;ij&quot;</span><span class="p">,</span><span class="n">pts</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">v2</span><span class="p">)</span> <span class="o">+</span>
                      <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&quot;i,j-&gt;ij&quot;</span><span class="p">,</span><span class="n">pts</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span><span class="n">v3</span><span class="p">))</span>
        <span class="n">diams</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">npts</span><span class="p">)</span>
        <span class="n">diams</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sizeDistribution</span><span class="p">(</span><span class="n">diams</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cloud</span><span class="o">.</span><span class="n">points</span>    <span class="o">=</span> <span class="n">pts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_diameters</span>      <span class="o">=</span> <span class="n">diams</span>
        
    <span class="k">def</span> <span class="nf">_sizeDistribution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seeds</span><span class="p">):</span>
        <span class="n">diam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>
        <span class="n">pdf</span>  <span class="o">=</span> <span class="n">gammainc</span><span class="p">(</span><span class="mf">13.9043</span><span class="p">,</span><span class="mf">10.9078</span><span class="o">*</span><span class="n">diam</span><span class="p">)</span><span class="o">**</span><span class="mf">0.2079</span>
        <span class="n">interpolator</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">pdf</span><span class="p">,</span> <span class="n">diam</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">interpolator</span><span class="p">(</span><span class="n">seeds</span><span class="p">)</span><span class="o">*</span><span class="mf">1e-6</span>  
    
    <span class="k">def</span> <span class="nf">scatteredEnergy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lineofsight</span><span class="p">,</span> <span class="n">lightvector</span><span class="p">,</span> <span class="n">solidangle</span><span class="p">,</span> 
                        <span class="n">wavelength</span> <span class="o">=</span> <span class="mf">532e-9</span><span class="p">,</span> <span class="n">polarization</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">lightintensity</span> <span class="o">=</span> <span class="n">Utils</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">lightvector</span><span class="p">)</span> 
<span class="c">#        lightvecnorm   = np.einsum(&quot;ij,i-&gt;ij&quot;, lightvector, 1/lightintensity)</span>
        
        <span class="n">scatterangle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">lineofsight</span><span class="o">*</span><span class="n">lightvector</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span>
                                 <span class="n">lightintensity</span><span class="p">)</span>
        <span class="c"># Replacing nans by suitable value</span>
        <span class="n">scatterangle</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">scatterangle</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">9999</span>
        <span class="n">minangle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">scatterangle</span><span class="p">)</span>
        <span class="n">scatterangle</span><span class="p">[</span><span class="n">scatterangle</span> <span class="o">==</span> <span class="mi">9999</span><span class="p">]</span> <span class="o">=</span> <span class="n">minangle</span>
<span class="c">#         plt.plot(scatterangle)</span>
<span class="c">#         plt.show()</span>
        
        <span class="k">print</span> <span class="s">&quot;Diameter range &quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">diameters</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">diameters</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">diameters</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">diameters</span><span class="p">):</span>
            <span class="n">diams</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">diameters</span><span class="p">),</span>
                                 <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">diameters</span><span class="p">),</span>
                                 <span class="mi">500</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">diams</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">diameters</span><span class="p">),</span> 
                              <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">diameters</span><span class="p">)</span><span class="o">+</span><span class="mf">1e-6</span><span class="p">])</span>
            
        <span class="k">print</span> <span class="s">&quot;Angle range &quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">scatterangle</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">scatterangle</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">scatterangle</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">scatterangle</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">scatterangle</span><span class="p">):</span>
            <span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">scatterangle</span><span class="p">),</span>
                                 <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">scatterangle</span><span class="p">),</span>
                                 <span class="mi">30</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">scatterangle</span><span class="p">),</span> 
                               <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">scatterangle</span><span class="p">)</span><span class="o">+</span><span class="mf">1e-6</span><span class="p">])</span>
        
        <span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">s2</span><span class="p">)</span> <span class="o">=</span> <span class="n">MieUtils</span><span class="o">.</span><span class="n">mieScatteringCrossSections</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">refractiveIndex</span><span class="p">(</span><span class="n">wavelength</span><span class="p">),</span> 
                                                      <span class="n">diams</span><span class="p">,</span> 
                                                      <span class="n">wavelength</span><span class="p">,</span> 
                                                      <span class="n">angles</span><span class="p">)</span>
        <span class="n">scs</span> <span class="o">=</span> <span class="p">(</span><span class="n">s1</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">polarization</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> 
               <span class="n">s2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">polarization</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>

        <span class="n">interpolant</span> <span class="o">=</span> <span class="n">RectBivariateSpline</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span>
                                          <span class="n">diams</span><span class="p">,</span>
                                          <span class="n">scs</span><span class="p">,</span>
                                          <span class="n">kx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ky</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
        
        <span class="n">scs</span>         <span class="o">=</span> <span class="n">interpolant</span><span class="o">.</span><span class="n">ev</span><span class="p">(</span><span class="n">scatterangle</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">diameters</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">scs</span><span class="o">*</span><span class="n">lightintensity</span><span class="o">*</span><span class="n">solidangle</span>
    </div>
<div class="viewcode-block" id="CalibrationPlate"><a class="viewcode-back" href="../../CalibrationPlate.html#pyvsim.Toolbox.CalibrationPlate">[docs]</a><span class="k">class</span> <span class="nc">CalibrationPlate</span><span class="p">(</span><span class="n">Seeding</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sidelength</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">):</span>
        <span class="n">Seeding</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="p">[</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">sidelength</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">sidelength</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="mi">100</span><span class="p">),</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">sidelength</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">sidelength</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="mi">100</span><span class="p">))</span>
        <span class="n">Z</span>     <span class="o">=</span> <span class="mi">0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">X</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span><span class="n">Y</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span><span class="n">Z</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> 
                                    <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1e-3</span><span class="p">,</span><span class="mf">1e-3</span><span class="p">,</span><span class="mf">1e-3</span><span class="p">])])</span>
<span class="c">#        print X.shape, Y.shape, Z.shape, self.points.shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">diameters</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.2e-6</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]))</span> <span class="o">+</span> 
                          <span class="mf">1e-10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])))</span>
        
        </div>
<div class="viewcode-block" id="Laser"><a class="viewcode-back" href="../../Laser.html#pyvsim.Toolbox.Laser">[docs]</a><span class="k">class</span> <span class="nc">Laser</span><span class="p">(</span><span class="n">Primitives</span><span class="o">.</span><span class="n">Assembly</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">Primitives</span><span class="o">.</span><span class="n">Assembly</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span>                       <span class="o">=</span> <span class="s">&#39;Laser &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transientFields</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s">&quot;profileInterpolator&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">body</span>                       <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rays</span>                       <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">volume</span>                     <span class="o">=</span> <span class="bp">None</span>
        <span class="c"># Plotting properties</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">color</span>                      <span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">opacity</span>                    <span class="o">=</span> <span class="mf">1.000</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>                  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.060</span><span class="p">,</span> <span class="mf">0.250</span><span class="p">,</span> <span class="mf">0.270</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wavelength</span>                 <span class="o">=</span> <span class="mf">532e-9</span>
        <span class="c"># Beam properties</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_profile</span>                   <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">profileInterpolator</span>        <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pulseEnergy</span>               <span class="o">=</span> <span class="mf">0.500</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_beamDivergence</span>            <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0005</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_beamDiameter</span>              <span class="o">=</span> <span class="mf">0.01</span><span class="c">#0.018</span>
        <span class="p">[</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">),</span> 
                            <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">profile</span>                    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.15</span><span class="o">*</span><span class="p">(</span><span class="n">X</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">Y</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="c"># Ray tracing characteristics</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">usefulLength</span>               <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">usefulLengthDiscretization</span> <span class="o">=</span> <span class="mf">0.1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">safeEnergyDensity</span>                 <span class="o">=</span> <span class="mf">5e-3</span> <span class="c">#1e-3</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">safetyTracingRays</span>          <span class="o">=</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">safetyTracingStrategy</span>      <span class="o">=</span> <span class="p">[[</span><span class="mi">7</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span>
                                           <span class="p">[</span><span class="mi">15</span><span class="p">,</span><span class="mf">0.05</span><span class="p">],</span>
                                           <span class="p">[</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_positionComponents</span><span class="p">()</span>
        
    <span class="nd">@property</span>    
    <span class="k">def</span> <span class="nf">profile</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_profile</span>
    <span class="nd">@profile.setter</span>
    <span class="k">def</span> <span class="nf">profile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">profileMatrix</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_profile</span> <span class="o">=</span> <span class="n">profileMatrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clearData</span><span class="p">()</span>
        
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pulseEnergy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pulseEnergy</span>
    <span class="nd">@pulseEnergy.setter</span>
    <span class="k">def</span> <span class="nf">pulseEnergy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">power</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pulseEnergy</span> <span class="o">=</span> <span class="n">power</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clearData</span><span class="p">()</span>
        
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">beamDivergence</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_beamDivergence</span>
    <span class="nd">@beamDivergence.setter</span>
    <span class="k">def</span> <span class="nf">beamDivergence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">div</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_beamDivergence</span> <span class="o">=</span> <span class="n">div</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clearData</span><span class="p">()</span>
        
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">beamDiameter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_beamDiameter</span>
    <span class="nd">@beamDiameter.setter</span>
    <span class="k">def</span> <span class="nf">beamDiameter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">diam</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_beamDiameter</span> <span class="o">=</span> <span class="n">diam</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clearData</span><span class="p">()</span>
        
    <span class="nd">@property</span>
<div class="viewcode-block" id="Laser.bounds"><a class="viewcode-back" href="../../Laser.html#pyvsim.Toolbox.Laser.bounds">[docs]</a>    <span class="k">def</span> <span class="nf">bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The laser participates in the ray tracing procedure only if it lays</span>
<span class="sd">        the volumes representing its light beam</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">volume</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="o">.</span><span class="n">bounds</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        </div>
    <span class="k">def</span> <span class="nf">display</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">facecolor</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s">&quot;equal&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="n">which</span> <span class="o">=</span> <span class="s">&quot;both&quot;</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="s">&quot;both&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&quot;Laser beam profile - J/m^2&quot;</span><span class="p">)</span>
        <span class="n">imgplot</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profile</span><span class="p">)</span>
        <span class="n">imgplot</span><span class="o">.</span><span class="n">set_interpolation</span><span class="p">(</span><span class="s">&#39;none&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>  
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        
    <span class="k">def</span> <span class="nf">clearData</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">energy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_profile</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beamDiameter</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> 
                                          <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_profile</span><span class="p">))</span>
<span class="c">#        print &quot;Energy&quot;, energy</span>
        <span class="n">multiplier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulseEnergy</span> <span class="o">/</span> <span class="n">energy</span>
<span class="c">#        print &quot;Multiplier&quot;, multiplier</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_profile</span>             <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_profile</span> <span class="o">*</span> <span class="n">multiplier</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">profileInterpolator</span>  <span class="o">=</span> <span class="n">RectBivariateSpline</span><span class="p">(</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_profile</span><span class="p">,</span><span class="mi">1</span><span class="p">)),</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_profile</span><span class="p">,</span><span class="mi">1</span><span class="p">)),</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">_profile</span><span class="p">,</span>
                                    <span class="n">kx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                                    <span class="n">ky</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">volume</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">volume</span>                     <span class="o">=</span> <span class="bp">None</span> 
            
        <span class="bp">self</span><span class="o">.</span><span class="n">_positionComponents</span><span class="p">()</span>
        
        <span class="n">Primitives</span><span class="o">.</span><span class="n">Assembly</span><span class="o">.</span><span class="n">clearData</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">_positionComponents</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TODO</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">body</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">body</span>           <span class="o">=</span> <span class="n">Primitives</span><span class="o">.</span><span class="n">Volume</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">body</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">color</span>     <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">color</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">opacity</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opacity</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">rays</span>           <span class="o">=</span> <span class="n">Primitives</span><span class="o">.</span><span class="n">RayBundle</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rays</span><span class="p">)</span>
        
        <span class="n">vectors</span>             <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,(</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="c"># Divergence in the xz plane</span>
        <span class="n">vectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">Utils</span><span class="o">.</span><span class="n">rotateVector</span><span class="p">(</span><span class="n">vectors</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> 
                                                <span class="bp">self</span><span class="o">.</span><span class="n">beamDivergence</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">),</span>
                             <span class="n">Utils</span><span class="o">.</span><span class="n">rotateVector</span><span class="p">(</span><span class="n">vectors</span><span class="p">[</span><span class="mi">2</span><span class="p">:],</span> 
                                                <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">beamDivergence</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)])</span>
        <span class="c"># Divergence in the xy plane</span>
        <span class="n">vectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">Utils</span><span class="o">.</span><span class="n">rotateVector</span><span class="p">(</span><span class="n">vectors</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                                                <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">beamDivergence</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">),</span>
                             <span class="n">Utils</span><span class="o">.</span><span class="n">rotateVector</span><span class="p">(</span><span class="n">vectors</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]],</span> 
                                                <span class="bp">self</span><span class="o">.</span><span class="n">beamDivergence</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">),</span>
                             <span class="n">Utils</span><span class="o">.</span><span class="n">rotateVector</span><span class="p">(</span><span class="n">vectors</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> 
                                                <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">beamDivergence</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">)])</span>
        <span class="c"># Position the four main rays with some spacing, according to the</span>
        <span class="c"># initial beam diameter</span>
        <span class="n">positions</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beamDiameter</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> 
                                     <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">,</span>
                                               <span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">,</span>
                                               <span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">,</span>
                                               <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">]))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vectors</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelength</span><span class="p">)</span>


<div class="viewcode-block" id="Laser.trace"><a class="viewcode-back" href="../../Laser.html#pyvsim.Toolbox.Laser.trace">[docs]</a>    <span class="k">def</span> <span class="nf">trace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates an assembly containing volumes representing the laser </span>
<span class="sd">        propagation. The volumes are created from usefulLength[0] to</span>
<span class="sd">        usefulLength[1], which is only a way to calculate less elements</span>
<span class="sd">        and reduce calculation costs, not an energy relation.</span>
<span class="sd">        </span>
<span class="sd">        Important parameters</span>
<span class="sd">            - Laser.usefulLength : the useful region of the laser sheet</span>
<span class="sd">            - Laser.usefulLengthDiscretization : the length of the discretization </span>
<span class="sd">            volume. Shorter elements provide better interpolation, but make</span>
<span class="sd">            computation extremely costly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rays</span><span class="o">.</span><span class="n">maximumRayTrace</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">usefulLength</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rays</span><span class="o">.</span><span class="n">stepRayTrace</span>      <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">usefulLength</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rays</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">tracingRule</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rays</span><span class="o">.</span><span class="n">TRACING_FOV</span><span class="p">)</span>
        
        <span class="n">start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rays</span><span class="o">.</span><span class="n">rayPaths</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">rays</span><span class="o">.</span><span class="n">maximumRayTrace</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">usefulLength</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rays</span><span class="o">.</span><span class="n">stepRayTrace</span>      <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">usefulLengthDiscretization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rays</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">tracingRule</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rays</span><span class="o">.</span><span class="n">TRACING_FOV</span><span class="p">,</span> <span class="n">restart</span><span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
        
        <span class="n">end</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rays</span><span class="o">.</span><span class="n">rayPaths</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">volume</span> <span class="o">=</span> <span class="n">Primitives</span><span class="o">.</span><span class="n">Assembly</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="p">)</span>
        <span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                        <span class="p">[</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                        <span class="p">[</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span>
                        <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">+</span><span class="mi">1</span><span class="p">]])</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">vol</span>                 <span class="o">=</span> <span class="n">Primitives</span><span class="o">.</span><span class="n">Volume</span><span class="p">(</span><span class="n">fastInit</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
            <span class="n">vol</span><span class="o">.</span><span class="n">surfaceProperty</span> <span class="o">=</span> <span class="n">vol</span><span class="o">.</span><span class="n">TRANSPARENT</span>
            <span class="n">vol</span><span class="o">.</span><span class="n">points</span>          <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">rays</span><span class="o">.</span><span class="n">rayPaths</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">rays</span><span class="o">.</span><span class="n">rayPaths</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]])</span>
            <span class="n">S1</span>                  <span class="o">=</span> <span class="n">Utils</span><span class="o">.</span><span class="n">quadArea</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rays</span><span class="o">.</span><span class="n">rayPaths</span><span class="p">[</span><span class="n">n</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> 
                                                 <span class="bp">self</span><span class="o">.</span><span class="n">rays</span><span class="o">.</span><span class="n">rayPaths</span><span class="p">[</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> 
                                                 <span class="bp">self</span><span class="o">.</span><span class="n">rays</span><span class="o">.</span><span class="n">rayPaths</span><span class="p">[</span><span class="n">n</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> 
                                                 <span class="bp">self</span><span class="o">.</span><span class="n">rays</span><span class="o">.</span><span class="n">rayPaths</span><span class="p">[</span><span class="n">n</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
            <span class="n">S2</span>                  <span class="o">=</span> <span class="n">Utils</span><span class="o">.</span><span class="n">quadArea</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rays</span><span class="o">.</span><span class="n">rayPaths</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> 
                                                 <span class="bp">self</span><span class="o">.</span><span class="n">rays</span><span class="o">.</span><span class="n">rayPaths</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> 
                                                 <span class="bp">self</span><span class="o">.</span><span class="n">rays</span><span class="o">.</span><span class="n">rayPaths</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> 
                                                 <span class="bp">self</span><span class="o">.</span><span class="n">rays</span><span class="o">.</span><span class="n">rayPaths</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
            <span class="n">vecs</span>                <span class="o">=</span> <span class="n">Utils</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rays</span><span class="o">.</span><span class="n">rayPaths</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span>
                                                  <span class="bp">self</span><span class="o">.</span><span class="n">rays</span><span class="o">.</span><span class="n">rayPaths</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
            <span class="n">vol</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">pts</span><span class="p">,</span><span class="n">pts</span><span class="p">)),</span>
                                  <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">vecs</span><span class="p">,</span><span class="n">vecs</span><span class="p">)),</span>
                                  <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">*</span><span class="n">S1</span><span class="p">,</span>
                                             <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">*</span><span class="n">S2</span><span class="p">))))</span>
            <span class="n">vol</span><span class="o">.</span><span class="n">color</span>           <span class="o">=</span> <span class="n">Utils</span><span class="o">.</span><span class="n">metersToRGB</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength</span><span class="p">)</span>
            <span class="n">vol</span><span class="o">.</span><span class="n">opacity</span>         <span class="o">=</span> <span class="mf">0.1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">volume</span> <span class="o">+=</span> <span class="n">vol</span>
            </div>
<div class="viewcode-block" id="Laser.illuminate"><a class="viewcode-back" href="../../Laser.html#pyvsim.Toolbox.Laser.illuminate">[docs]</a>    <span class="k">def</span> <span class="nf">illuminate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pts</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a set of points in space, this method calculates the light </span>
<span class="sd">        intensity (in :math:`J/m^2`) and direction produced by the laser.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pts : numpy.array (N,3)</span>
<span class="sd">            A number of points in space</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        intensity : numpy.array (N,3)</span>
<span class="sd">            A vector which norm is the light intensity (in :math:`J/m^2`) pointing to</span>
<span class="sd">            the direction that the light emanating from the laser is</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span><span class="mi">1</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">vol</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="n">vol</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span>

        <span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
        <span class="n">vecs</span>  <span class="o">=</span> <span class="n">Utils</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">result</span><span class="p">[:,</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">])</span>
        <span class="n">S</span>     <span class="o">=</span> <span class="n">result</span><span class="p">[:,</span><span class="mi">5</span><span class="p">]</span> 
        <span class="n">intensity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">profileInterpolator</span><span class="o">.</span><span class="n">ev</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beamDiameter</span> <span class="o">**</span> <span class="mi">2</span><span class="o">/</span>
                                                         <span class="n">S</span><span class="p">)</span>
        <span class="n">intensity</span><span class="p">[</span><span class="n">S</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&quot;ij,i-&gt;ij&quot;</span><span class="p">,</span><span class="n">vecs</span><span class="p">,</span> <span class="n">intensity</span><span class="p">)</span>
            </div>
<div class="viewcode-block" id="Laser.traceReflections"><a class="viewcode-back" href="../../Laser.html#pyvsim.Toolbox.Laser.traceReflections">[docs]</a>    <span class="k">def</span> <span class="nf">traceReflections</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        POC implementation of a calculation of laser safety distances</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Calculate how many rays will be generated</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">safetyTracingRays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">n2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">safetyTracingRays</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">nrays</span>  <span class="o">=</span> <span class="n">n1</span><span class="o">*</span><span class="n">n2</span> 
        
        <span class="c"># Create a grid of positions for the rays to start</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n2</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n1</span><span class="p">)</span>
        <span class="p">[</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">Y</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> 
                            <span class="n">X</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> 
                            <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nrays</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span>
                            
        <span class="c"># Calculate where these rays should be in the laser output</span>
        <span class="n">physicalPoints</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&quot;i,j-&gt;ij&quot;</span><span class="p">,</span><span class="n">points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">*</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">beamDiameter</span><span class="o">*</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">n1</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">n1</span><span class="o">-</span><span class="mi">2</span><span class="p">))</span> <span class="o">+</span>
                          <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&quot;i,j-&gt;ij&quot;</span><span class="p">,</span><span class="n">points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="o">*</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">beamDiameter</span><span class="o">*</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">n2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">n2</span><span class="o">-</span><span class="mi">2</span><span class="p">)))</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

<span class="c">#        physicalPoints = physicalPoints * (self.beamDiameter * (nside-1) / </span>
<span class="c">#                                           (2*(nside-2)))</span>
        <span class="n">physicalPoints</span> <span class="o">=</span> <span class="n">physicalPoints</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span>
        
        <span class="c"># For each ray, calculate their corresponding initial propagation vector</span>
        <span class="n">vectors</span> <span class="o">=</span> <span class="n">Utils</span><span class="o">.</span><span class="n">quadInterpolation</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> 
                                          <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
                                                    <span class="p">[</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
                                                    <span class="p">[</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
                                                    <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]]),</span> 
                                          <span class="bp">self</span><span class="o">.</span><span class="n">rays</span><span class="o">.</span><span class="n">initialVectors</span><span class="p">)</span>
        
        <span class="n">vectors</span> <span class="o">=</span> <span class="n">Utils</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">vectors</span><span class="p">)</span>
        
        <span class="n">bundle</span> <span class="o">=</span> <span class="n">Primitives</span><span class="o">.</span><span class="n">RayBundle</span><span class="p">()</span>
        <span class="n">bundle</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vectors</span><span class="p">,</span> 
                      <span class="n">physicalPoints</span><span class="p">,</span> 
                      <span class="bp">self</span><span class="o">.</span><span class="n">wavelength</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bundle</span><span class="p">)</span>       
         
        <span class="n">restart</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">tic</span> <span class="o">=</span> <span class="n">Utils</span><span class="o">.</span><span class="n">Tictoc</span><span class="p">()</span>
        
        <span class="k">for</span> <span class="n">length</span><span class="p">,</span> <span class="n">step</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">safetyTracingStrategy</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;Tracing up to length </span><span class="si">%f</span><span class="s"> with step </span><span class="si">%f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
            <span class="n">bundle</span><span class="o">.</span><span class="n">maximumRayTrace</span>  <span class="o">=</span> <span class="n">length</span>
            <span class="n">bundle</span><span class="o">.</span><span class="n">stepRayTrace</span>     <span class="o">=</span> <span class="n">step</span>
            <span class="n">tic</span><span class="o">.</span><span class="n">tic</span><span class="p">()</span>
            <span class="n">bundle</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">tracingRule</span> <span class="o">=</span> <span class="n">bundle</span><span class="o">.</span><span class="n">TRACING_LASER_REFLECTION</span><span class="p">,</span> 
                         <span class="n">restart</span> <span class="o">=</span> <span class="n">restart</span><span class="p">)</span>
            <span class="n">restart</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">tic</span><span class="o">.</span><span class="n">toc</span><span class="p">()</span>
        
<span class="c">#        initial_density =  self.pulseEnergy / (self.beamDiameter**2/</span>
<span class="c">#                                               ((n1-1)*(n2-1)))</span>
<span class="c">#        initial_energy  =  self.pulseEnergy / ((n1-2)*(n2-2))</span>
        <span class="n">energyDensity</span>           <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n1</span><span class="p">,</span><span class="n">n2</span><span class="p">))</span>
        <span class="n">initialEnergyDensity</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">profileInterpolator</span><span class="o">.</span><span class="n">ev</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> 
                                                              <span class="n">points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">initialEnergyDensity</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">initialEnergyDensity</span><span class="p">,(</span><span class="n">n1</span><span class="p">,</span><span class="n">n2</span><span class="p">))</span>
        <span class="n">referenceArea</span>           <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beamDiameter</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">((</span><span class="n">n1</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">n2</span><span class="o">-</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">maxEnergyDensity</span>        <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">initialEnergyDensity</span><span class="p">)</span>
<span class="c">#        print &quot;maxEd %s&quot; % maxEnergyDensity</span>

        <span class="c"># We will create a connectivity map for a rectangle with side n-1, as</span>
        <span class="c"># we will take the centerpoint for each 4 rays</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">((</span><span class="n">n1</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">n2</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n</span><span class="p">,(</span><span class="n">n1</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n2</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>

        <span class="n">cts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(((</span><span class="n">n2</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">n1</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span><span class="mi">4</span><span class="p">))</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n1</span><span class="o">-</span><span class="mi">2</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n2</span><span class="o">-</span><span class="mi">2</span><span class="p">):</span>
                <span class="n">cts</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">],</span> <span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">]]</span>
                <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">cts</span> <span class="o">=</span> <span class="n">cts</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                
        <span class="n">color</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">bundle</span><span class="o">.</span><span class="n">steps</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">nrays</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="c">#        print bundle.steps</span>
<span class="c">#        print color.shape</span>
                

        
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">bundle</span><span class="o">.</span><span class="n">rayPaths</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
            <span class="c"># arrange the rays in the grid they originally were</span>
            <span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">bundle</span><span class="o">.</span><span class="n">rayPaths</span><span class="p">[</span><span class="n">n</span><span class="p">],(</span><span class="n">n1</span><span class="p">,</span><span class="n">n2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
            <span class="c"># find the mean points of each 4 rays</span>
            <span class="n">pts</span> <span class="o">=</span> <span class="mf">0.25</span><span class="o">*</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">pts</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">pts</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:])</span>
            <span class="c"># reshape in a list of points</span>
            <span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">pts</span><span class="p">,(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
            <span class="c"># calculate the area of each of the new quads (using our nice</span>
            <span class="c"># connectivity list)</span>
            <span class="n">area</span> <span class="o">=</span> <span class="n">Utils</span><span class="o">.</span><span class="n">quadArea</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="n">cts</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]],</span> 
                                  <span class="n">pts</span><span class="p">[</span><span class="n">cts</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]],</span>
                                  <span class="n">pts</span><span class="p">[</span><span class="n">cts</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]],</span>
                                  <span class="n">pts</span><span class="p">[</span><span class="n">cts</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]])</span>
            <span class="n">area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">area</span><span class="p">,(</span><span class="n">n1</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="n">n2</span><span class="o">-</span><span class="mi">2</span><span class="p">))</span>
            <span class="n">energyDensity</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">initialEnergyDensity</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span>
                                        <span class="n">referenceArea</span> <span class="o">/</span> <span class="n">area</span><span class="p">)</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">energyDensity</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
<span class="c">#            print &quot;E %s&quot; % np.max(e)</span>
            <span class="n">color</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">Utils</span><span class="o">.</span><span class="n">jet</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">e</span><span class="o">+</span><span class="mf">1e-5</span><span class="p">),</span>
                                 <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">safeEnergyDensity</span><span class="p">),</span>
                                 <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">maxEnergyDensity</span><span class="p">),</span>
                                 <span class="n">saturationIndicator</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span><span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bundle</span><span class="p">):</span>
            <span class="n">line</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">color</span><span class="p">[:,</span><span class="n">n</span><span class="p">]</span>
            <span class="n">line</span><span class="o">.</span><span class="n">width</span> <span class="o">=</span> <span class="mi">2</span>
        
        <span class="c"># The rays at the margin (that receive density zero) are then &quot;erased&quot;</span>
        <span class="n">toerase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n1</span><span class="o">*</span><span class="n">n2</span><span class="p">),(</span><span class="n">n1</span><span class="p">,</span><span class="n">n2</span><span class="p">))</span>
        <span class="n">toerase</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> 
        <span class="n">toerase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">toerase</span><span class="o">.</span><span class="n">ravel</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span> 
        <span class="c"># This trick does not work for</span>
        <span class="c"># ray[0,0], so:</span>
        <span class="n">bundle</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">opacity</span> <span class="o">=</span> <span class="mi">0</span>                                         
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">toerase</span><span class="p">:</span>
            <span class="n">bundle</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">opacity</span> <span class="o">=</span> <span class="mi">0</span>
            
    </div></div>
<span class="k">if</span> <span class="n">__name__</span><span class="o">==</span><span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">System</span>
    <span class="kn">import</span> <span class="nn">copy</span>
    <span class="kn">import</span> <span class="nn">Library</span>
    <span class="n">tic</span> <span class="o">=</span> <span class="n">Utils</span><span class="o">.</span><span class="n">Tictoc</span><span class="p">()</span>
    
    <span class="n">c</span>                               <span class="o">=</span> <span class="n">Camera</span><span class="p">()</span>
    <span class="n">c</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">focusingDistance</span>         <span class="o">=</span> <span class="mi">1</span><span class="c">#.9695 #0.9725</span>
    <span class="n">c</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">aperture</span>                 <span class="o">=</span> <span class="mi">2</span>
    <span class="n">c</span><span class="o">.</span><span class="n">mappingResolution</span>             <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">c</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">distortionParameters</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span>
                                                <span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span>
                                                <span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
    <span class="c"># Put the sensor at the position [0,0,0] to make verification easier</span>
    <span class="n">c</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">c</span><span class="o">.</span><span class="n">sensorPosition</span><span class="p">)</span>
    
    <span class="n">scheimpflug</span> <span class="o">=</span> <span class="mi">0</span><span class="o">*-</span><span class="mf">0.75</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">180</span>
    <span class="n">c</span><span class="o">.</span><span class="n">setScheimpflugAngle</span><span class="p">(</span><span class="n">scheimpflug</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="c">#    c.rotate(-scheimpflug,     c.y, c.x*c.sensorPosition)</span>
<span class="c">#    c.lens.rotate(scheimpflug, c.y, c.x*c.sensorPosition)</span>

    <span class="n">l</span>                               <span class="o">=</span> <span class="n">Laser</span><span class="p">()</span>
<span class="c">#    l.beamDivergence                = np.array([0.5e-3, 0.25])</span>
    <span class="n">l</span><span class="o">.</span><span class="n">beamDivergence</span>                <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">7e-3</span><span class="p">,</span> <span class="mf">4.596e-2</span><span class="p">])</span>
    <span class="n">l</span><span class="o">.</span><span class="n">pulseEnergy</span>                   <span class="o">=</span> <span class="mf">5.005</span><span class="c"># 0.1</span>
    <span class="n">l</span><span class="o">.</span><span class="n">_positionComponents</span><span class="p">()</span>
    <span class="n">l</span><span class="o">.</span><span class="n">alignTo</span><span class="p">(</span><span class="o">-</span><span class="n">l</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">l</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="o">-</span><span class="n">l</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]))</span>
    <span class="n">l</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">0</span><span class="p">]))</span>
    <span class="n">l</span><span class="o">.</span><span class="n">usefulLength</span>                  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.55</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">])</span>
    <span class="n">l</span><span class="o">.</span><span class="n">usefulLengthDiscretization</span>    <span class="o">=</span> <span class="mf">0.1</span>
    <span class="n">l</span><span class="o">.</span><span class="n">safetyTracingRays</span>             <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">100</span><span class="p">]</span>
    <span class="n">l</span><span class="o">.</span><span class="n">safetyTracingStrategy</span>         <span class="o">=</span> <span class="p">[[</span><span class="mi">4</span><span class="p">,</span><span class="o">.</span><span class="mo">01</span><span class="p">]]</span>
    
    
    
    <span class="n">v</span>                               <span class="o">=</span> <span class="n">Primitives</span><span class="o">.</span><span class="n">Volume</span><span class="p">()</span>
<span class="c">#    v.rotate(np.pi/9, v.z)</span>
    <span class="n">v</span><span class="o">.</span><span class="n">opacity</span>                       <span class="o">=</span> <span class="mf">0.1</span>
    <span class="n">v</span><span class="o">.</span><span class="n">dimension</span>                     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
    <span class="n">v</span><span class="o">.</span><span class="n">material</span>                      <span class="o">=</span> <span class="n">Library</span><span class="o">.</span><span class="n">IdealMaterial</span><span class="p">()</span>
    <span class="n">v</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">value</span>                <span class="o">=</span> <span class="mf">1.33</span>
    <span class="n">v</span><span class="o">.</span><span class="n">surfaceProperty</span>               <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">TRANSPARENT</span>
    <span class="n">v</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.35</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">0</span><span class="p">]))</span> 
    
    <span class="n">v2</span>                              <span class="o">=</span> <span class="n">Primitives</span><span class="o">.</span><span class="n">Volume</span><span class="p">()</span>
    <span class="n">v2</span><span class="o">.</span><span class="n">dimension</span>                    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0001</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
    <span class="n">v2</span><span class="o">.</span><span class="n">surfaceProperty</span>              <span class="o">=</span> <span class="n">v2</span><span class="o">.</span><span class="n">MIRROR</span>
<span class="c">#    v2.surfaceProperty              = v.TRANSPARENT </span>
    <span class="n">v2</span><span class="o">.</span><span class="n">material</span>                     <span class="o">=</span> <span class="n">Library</span><span class="o">.</span><span class="n">IdealMaterial</span><span class="p">()</span>
    <span class="n">v2</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">value</span>               <span class="o">=</span> <span class="mi">1</span>
    <span class="n">v2</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]))</span>
    <span class="n">v2</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span><span class="n">v2</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>

<span class="c">#    seed                            = Seeding()</span>
<span class="c">#    seed.points                     = (np.array([0.5,0.5,0]) + </span>
<span class="c">#                                       0.02*Primitives.Volume.PARAMETRIC_COORDS)</span>
<span class="c">#    seed.density                    = 1e11 / 800*3</span>
<span class="c">#    seed.seed()</span>
    
    <span class="n">seed</span> <span class="o">=</span> <span class="n">CalibrationPlate</span><span class="p">()</span>
    <span class="n">seed</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">0</span><span class="p">]))</span>
    <span class="n">seed</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="mf">1.570796327</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]))</span>    


    <span class="n">environment</span> <span class="o">=</span> <span class="n">Primitives</span><span class="o">.</span><span class="n">Assembly</span><span class="p">()</span>
    <span class="n">environment</span> <span class="o">+=</span> <span class="n">seed</span>
    <span class="n">environment</span> <span class="o">+=</span> <span class="n">c</span>
<span class="c">#    environment += v</span>
    <span class="n">environment</span> <span class="o">+=</span> <span class="n">v2</span>
    <span class="n">environment</span> <span class="o">+=</span> <span class="n">l</span>

<span class="c">#    Some geometrical transformations to make the problem more interesting</span>
    <span class="n">c</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="mi">90</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">180</span><span class="p">,</span><span class="n">c</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>    
<span class="c">#    environment.rotate(np.pi/0.1314, c.x)</span>
<span class="c">#    environment.rotate(np.pi/27, c.y)</span>
<span class="c">#    environment.rotate(np.pi/2.1, c.z)</span>

    <span class="n">npts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">seed</span><span class="o">.</span><span class="n">points</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="k">print</span> <span class="s">&quot;Laser sheet tracing&quot;</span>
    <span class="n">tic</span><span class="o">.</span><span class="n">tic</span><span class="p">()</span>
    <span class="n">l</span><span class="o">.</span><span class="n">trace</span><span class="p">()</span>
    <span class="n">tic</span><span class="o">.</span><span class="n">toc</span><span class="p">()</span> 
    
    <span class="k">print</span> <span class="s">&quot;Laser sheet safety tracing&quot;</span>
    <span class="n">tic</span><span class="o">.</span><span class="n">tic</span><span class="p">()</span>
    <span class="n">l</span><span class="o">.</span><span class="n">traceReflections</span><span class="p">()</span>
    <span class="n">tic</span><span class="o">.</span><span class="n">toc</span><span class="p">()</span>     

    <span class="k">print</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Camera parameter determination&quot;</span>
    <span class="n">tic</span><span class="o">.</span><span class="n">tic</span><span class="p">()</span>
    <span class="n">c</span><span class="o">.</span><span class="n">initialize</span><span class="p">()</span>
    <span class="n">tic</span><span class="o">.</span><span class="n">toc</span><span class="p">()</span>
    
    <span class="k">print</span> <span class="n">c</span><span class="o">.</span><span class="n">virtualApertureArea</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="mf">0.05</span><span class="o">/</span><span class="n">c</span><span class="o">.</span><span class="n">lens</span><span class="o">.</span><span class="n">aperture</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>   
    
    <span class="sd">&quot;&quot;&quot;Calculate the position of each point in the sensor&quot;&quot;&quot;</span>
    <span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">duvw</span><span class="p">,</span> <span class="n">lineofsight</span><span class="p">,</span> <span class="n">imdim</span><span class="p">,</span> <span class="n">sldangle</span><span class="p">)</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">mapPoints</span><span class="p">(</span><span class="n">seed</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
    
    <span class="sd">&quot;&quot;&quot;Calculate the incoming light&quot;&quot;&quot;</span>
    <span class="k">print</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Illumination phase&quot;</span>
    <span class="n">tic</span><span class="o">.</span><span class="n">tic</span><span class="p">()</span>
    <span class="n">lightvector</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">illuminate</span><span class="p">(</span><span class="n">seed</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
    <span class="n">tic</span><span class="o">.</span><span class="n">toc</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">seed</span><span class="o">.</span><span class="n">points</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>


    <span class="n">tic</span><span class="o">.</span><span class="n">tic</span><span class="p">()</span>
    <span class="n">energy</span> <span class="o">=</span> <span class="n">seed</span><span class="o">.</span><span class="n">scatteredEnergy</span><span class="p">(</span><span class="n">lineofsight</span>  <span class="o">=</span> <span class="n">lineofsight</span><span class="p">,</span> 
                                  <span class="n">lightvector</span>  <span class="o">=</span> <span class="n">lightvector</span><span class="p">,</span> 
                                  <span class="n">solidangle</span>   <span class="o">=</span> <span class="n">sldangle</span><span class="p">,</span> 
                                  <span class="n">wavelength</span>   <span class="o">=</span> <span class="mf">532e-9</span><span class="p">,</span> 
                                  <span class="n">polarization</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">tic</span><span class="o">.</span><span class="n">toc</span><span class="p">(</span><span class="n">npts</span><span class="p">)</span>

    <span class="n">tic</span><span class="o">.</span><span class="n">tic</span><span class="p">()</span>
    <span class="n">c</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">recordParticles</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> 
                             <span class="n">energy</span><span class="p">,</span> 
                             <span class="mf">532e-9</span><span class="p">,</span> 
                             <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">imdim</span><span class="p">))</span>
    <span class="n">tic</span><span class="o">.</span><span class="n">toc</span><span class="p">(</span><span class="n">npts</span><span class="p">)</span>
    
    <span class="k">print</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Saving image&quot;</span>
    <span class="n">tic</span><span class="o">.</span><span class="n">tic</span><span class="p">()</span>
    <span class="n">c</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s">&quot;test01.tif&quot;</span><span class="p">)</span>
    <span class="n">tic</span><span class="o">.</span><span class="n">toc</span><span class="p">()</span>
    <span class="n">c</span><span class="o">.</span><span class="n">sensor</span><span class="o">.</span><span class="n">display</span><span class="p">(</span><span class="s">&quot;jet&quot;</span><span class="p">)</span>
    
    <span class="n">vc</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">virtualCameras</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">environment</span> <span class="o">+=</span> <span class="n">vc</span>
<span class="c">#    </span>

    <span class="n">System</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">environment</span><span class="p">)</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../static/logo.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">pyvsim 1.0 documentation</a> &raquo;</li>
          <li><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Ricardo Entz.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>