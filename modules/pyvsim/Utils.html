

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pyvsim.Utils &mdash; pyvsim 1.0 documentation</title>
    
    <link rel="stylesheet" href="../../static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../static/jquery.js"></script>
    <script type="text/javascript" src="../../static/underscore.js"></script>
    <script type="text/javascript" src="../../static/doctools.js"></script>
    <link rel="top" title="pyvsim 1.0 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">pyvsim 1.0 documentation</a> &raquo;</li>
          <li><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for pyvsim.Utils</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">.. module :: Utils</span>
<span class="sd">    :platform: Unix, Windows</span>
<span class="sd">    :synopsis: Helper functions</span>
<span class="sd">    </span>
<span class="sd">This module packs all kinds of helper classes, mostly for mathematical problem</span>
<span class="sd">solving.</span>
<span class="sd">    </span>
<span class="sd">.. moduleauthor :: Ricardo Entz &lt;maiko at thebigheads.net&gt;</span>

<span class="sd">.. license::</span>
<span class="sd">    PyVSim v.1</span>
<span class="sd">    Copyright 2013 Ricardo Entz</span>
<span class="sd">    </span>
<span class="sd">    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="sd">    you may not use this file except in compliance with the License.</span>
<span class="sd">    You may obtain a copy of the License at</span>
<span class="sd">    </span>
<span class="sd">        http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="sd">    </span>
<span class="sd">    Unless required by applicable law or agreed to in writing, software</span>
<span class="sd">    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="sd">    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="sd">    See the License for the specific language governing permissions and</span>
<span class="sd">    limitations under the License.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.linalg</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">ConfigParser</span>

<span class="n">CONFIG_FILE</span> <span class="o">=</span> <span class="s">&quot;./config.dat&quot;</span>

<span class="n">HEXA_CONNECTIVITY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span>
                             <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span>
                             <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span>
                             <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span>
                             <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span>
                             <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span>
                             <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span>
                             <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span>
                             <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span>
                             <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span>
                             <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span>
                             <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">]])</span>

<span class="n">HEXA_FACES_PER_NODE</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span>
                                  <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span>
                                  <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
                                  <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
                                  <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span>
                                  <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span>
                                  <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span>
                                  <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>

<span class="c"># Definition of triangles using the hexa points</span>
<span class="n">HEXA_CONN_PARTIAL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
                            <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
                            <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
                            <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span>
                            <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span>
                            <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">]])</span>

<div class="viewcode-block" id="readConfig"><a class="viewcode-back" href="../../readConfig.html#pyvsim.Utils.readConfig">[docs]</a><span class="k">def</span> <span class="nf">readConfig</span><span class="p">(</span><span class="n">section</span><span class="p">,</span> <span class="n">field</span><span class="p">):</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">ConfigParser</span><span class="o">.</span><span class="n">SafeConfigParser</span><span class="p">()</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">CONFIG_FILE</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">parser</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">section</span><span class="p">,</span> <span class="n">field</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="hexaInterpolation"><a class="viewcode-back" href="../../hexaInterpolation.html#pyvsim.Utils.hexaInterpolation">[docs]</a><span class="k">def</span> <span class="nf">hexaInterpolation</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">hexapoints</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function interpolates values given on vertices of an hexahedron to </span>
<span class="sd">    a point. The algorithm relies on the ratio of volumes of tetrahedrons</span>
<span class="sd">    defined by the hexa faces and the point, and its behavior is approximately</span>
<span class="sd">    linear.</span>
<span class="sd">    </span>
<span class="sd">    **Warning** - there is no verification whether the points are inside the </span>
<span class="sd">    hexahedron. One must check it using other methods.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    p : numpy.array (N, 3)</span>
<span class="sd">        List of points to be interpolated</span>
<span class="sd">    hexapoints : numpy.array (8, 3)</span>
<span class="sd">        List of points defining the hexahedron</span>
<span class="sd">    values : numpy.array (M, 8)</span>
<span class="sd">        List of values at the vertices of the hexahedron</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    interpolated : numpy.array (N, M)</span>
<span class="sd">        Values interpolated at points p</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="p">(</span><span class="n">hexapoints</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">values</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">8</span>
    
    <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c"># This is done if only one point is given</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">p</span><span class="p">,(</span><span class="mi">1</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span>

    <span class="c"># Creates the list of coordinates of the tetrahedrons</span>
    <span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">p</span><span class="p">,(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="mi">1</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="mi">1</span><span class="p">)))</span>
    <span class="n">p2</span> <span class="o">=</span> <span class="p">[</span><span class="n">hexapoints</span><span class="p">[</span><span class="n">HEXA_CONNECTIVITY</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]]]</span>
    <span class="n">p3</span> <span class="o">=</span> <span class="p">[</span><span class="n">hexapoints</span><span class="p">[</span><span class="n">HEXA_CONNECTIVITY</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]]]</span>
    <span class="n">p4</span> <span class="o">=</span> <span class="p">[</span><span class="n">hexapoints</span><span class="p">[</span><span class="n">HEXA_CONNECTIVITY</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]]]</span>

    <span class="c"># The lists are repeated to match dimensions</span>
    <span class="c"># Notice that there are 12, as it&#39;s not possible to calculate the volume of</span>
    <span class="c"># a tetra with square base</span>
    <span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">p1</span><span class="p">,(</span><span class="mi">1</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">p2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">p2</span><span class="p">,(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">p3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">p3</span><span class="p">,(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">p4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">p4</span><span class="p">,(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    
    <span class="c"># Calculate the volumes</span>
    <span class="n">tetraVols</span> <span class="o">=</span> <span class="n">tetraVolume</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">,</span><span class="n">p3</span><span class="p">,</span><span class="n">p4</span><span class="p">)</span>
    
    <span class="c"># Allocates list to store the tetra volumes</span>
    <span class="c"># Notice there are only 6 slots, so we have to add the areas</span>
    <span class="n">Vp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="mi">6</span><span class="p">))</span>

    <span class="c"># We have to sum the areas to obtain the volume of tetras with quad base</span>
    <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">Vp</span><span class="p">[:,</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">tetraVols</span><span class="p">[:,</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">tetraVols</span><span class="p">[:,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c"># Takes the area of opposite hexahedrons</span>
    <span class="n">den</span> <span class="o">=</span> <span class="p">(</span><span class="n">Vp</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">Vp</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">Vp</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">Vp</span><span class="p">[:,</span><span class="mi">3</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">Vp</span><span class="p">[:,</span><span class="mi">5</span><span class="p">]</span> <span class="o">+</span> <span class="n">Vp</span><span class="p">[:,</span><span class="mi">4</span><span class="p">])</span>

    <span class="c"># Now we take the corresponding volumes per node and divide by the factor</span>
    <span class="c"># calculated above. This yields the weights to average the values</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">Vp</span><span class="p">[:,</span><span class="n">HEXA_FACES_PER_NODE</span><span class="p">],</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">den</span><span class="p">,(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="mi">1</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">values</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">C</span> <span class="o">*</span> <span class="n">values</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">C</span><span class="p">,(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">C</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="mi">1</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">values</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">values</span><span class="o">.</span><span class="n">T</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">C</span> <span class="o">*</span> <span class="n">values</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

    
    
    </div>
<div class="viewcode-block" id="tetraVolume"><a class="viewcode-back" href="../../tetraVolume.html#pyvsim.Utils.tetraVolume">[docs]</a><span class="k">def</span> <span class="nf">tetraVolume</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">,</span><span class="n">p3</span><span class="p">,</span><span class="n">p4</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the volume of a tetrahedron. This is simply the unrolled</span>
<span class="sd">    determinant:</span>
<span class="sd">    </span>
<span class="sd">    .. math::</span>
<span class="sd">    </span>
<span class="sd">        \\left [ \\begin{array}{ccc}</span>
<span class="sd">        V_{x,1} &amp; V_{y,1} &amp;  V_{z,1} \\\\</span>
<span class="sd">        V_{x,2} &amp; V_{y,2} &amp;  V_{z,2} \\\\</span>
<span class="sd">        V_{x,3} &amp; V_{y,3} &amp;  V_{z,3} \\end{array} \\right ] \\cdot {1 \\over 6}</span>
<span class="sd">        </span>
<span class="sd">    With:</span>
<span class="sd">    </span>
<span class="sd">    .. math::</span>
<span class="sd">        \\vec{V}_1 = \\vec{P}_1 - \\vec{P}_4</span>
<span class="sd">        </span>
<span class="sd">        \\vec{V}_2 = \\vec{P}_2 - \\vec{P}_4</span>
<span class="sd">        </span>
<span class="sd">        \\vec{V}_3 = \\vec{P}_3 - \\vec{P}_4</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    This function works only for list of vectors, for performance reasons</span>
<span class="sd">    will not check the inputs, will throw an error instead.</span>
<span class="sd">    </span>
<span class="sd">    (This works faster than numpy.linalg.det repeated over the list of</span>
<span class="sd">    tetrahedrons)</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    p1, p2, p3, p4 : numpy.ndarray (N,3)</span>
<span class="sd">        The points of the N tetrahedrons.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    v : numpy.ndarray (N)</span>
<span class="sd">        The volume of the tetrahedrons.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">p1</span><span class="o">-</span><span class="n">p4</span><span class="p">,</span> <span class="n">p2</span><span class="o">-</span><span class="n">p4</span><span class="p">,</span> <span class="n">p3</span><span class="o">-</span><span class="n">p4</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">p1</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">6</span><span class="p">)</span><span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">vecs</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">vecs</span><span class="p">[</span><span class="mi">1</span><span class="p">,:,:,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">vecs</span><span class="p">[</span><span class="mi">2</span><span class="p">,:,:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span>
                             <span class="n">vecs</span><span class="p">[</span><span class="mi">2</span><span class="p">,:,:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">vecs</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,:,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">vecs</span><span class="p">[</span><span class="mi">1</span><span class="p">,:,:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span>
                             <span class="n">vecs</span><span class="p">[</span><span class="mi">1</span><span class="p">,:,:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">vecs</span><span class="p">[</span><span class="mi">2</span><span class="p">,:,:,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">vecs</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span>
                             <span class="n">vecs</span><span class="p">[</span><span class="mi">2</span><span class="p">,:,:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">vecs</span><span class="p">[</span><span class="mi">1</span><span class="p">,:,:,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">vecs</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span>
                             <span class="n">vecs</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">vecs</span><span class="p">[</span><span class="mi">2</span><span class="p">,:,:,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">vecs</span><span class="p">[</span><span class="mi">1</span><span class="p">,:,:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span>
                             <span class="n">vecs</span><span class="p">[</span><span class="mi">1</span><span class="p">,:,:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">vecs</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,:,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">vecs</span><span class="p">[</span><span class="mi">2</span><span class="p">,:,:,</span><span class="mi">2</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">6</span><span class="p">)</span><span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">vecs</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">vecs</span><span class="p">[</span><span class="mi">1</span><span class="p">,:,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">vecs</span><span class="p">[</span><span class="mi">2</span><span class="p">,:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span>
                             <span class="n">vecs</span><span class="p">[</span><span class="mi">2</span><span class="p">,:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">vecs</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">vecs</span><span class="p">[</span><span class="mi">1</span><span class="p">,:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span>
                             <span class="n">vecs</span><span class="p">[</span><span class="mi">1</span><span class="p">,:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">vecs</span><span class="p">[</span><span class="mi">2</span><span class="p">,:,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">vecs</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span>
                             <span class="n">vecs</span><span class="p">[</span><span class="mi">2</span><span class="p">,:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">vecs</span><span class="p">[</span><span class="mi">1</span><span class="p">,:,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">vecs</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span>
                             <span class="n">vecs</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">vecs</span><span class="p">[</span><span class="mi">2</span><span class="p">,:,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">vecs</span><span class="p">[</span><span class="mi">1</span><span class="p">,:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span>
                             <span class="n">vecs</span><span class="p">[</span><span class="mi">1</span><span class="p">,:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">vecs</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">vecs</span><span class="p">[</span><span class="mi">2</span><span class="p">,:,</span><span class="mi">2</span><span class="p">])</span> 
</div>
<div class="viewcode-block" id="jet"><a class="viewcode-back" href="../../jet.html#pyvsim.Utils.jet">[docs]</a><span class="k">def</span> <span class="nf">jet</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">minval</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">maxval</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">saturationIndicator</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the RGB values to emulate a &quot;jet&quot; colormap from Matlab</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    value : numpy.ndarray(N)</span>
<span class="sd">        The value to be represented by the colormap</span>
<span class="sd">        </span>
<span class="sd">    minval : float</span>
<span class="sd">        The minimum value of the scale. Defaults to the minimum of the values in</span>
<span class="sd">        the parameter &quot;value&quot;</span>
<span class="sd">        </span>
<span class="sd">    maxval : float </span>
<span class="sd">        The maximum value of the scale. Defaults to the maximum of the values in</span>
<span class="sd">        the parameter &quot;value&quot;.</span>
<span class="sd">        </span>
<span class="sd">    saturationIndication : boolean</span>
<span class="sd">        Substitute the default saturation values (red and blue) for white,</span>
<span class="sd">        providing better contrast when saturated values are of interest.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">minval</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">minval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">maxval</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">maxval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        
    <span class="n">val</span>   <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">value</span> <span class="o">-</span> <span class="n">minval</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">maxval</span><span class="o">-</span><span class="n">minval</span><span class="p">)</span>
    <span class="n">rmask</span> <span class="o">=</span> <span class="n">val</span> <span class="o">-</span> <span class="mf">1.5</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">val</span> <span class="o">+</span> <span class="mf">4.5</span>
    <span class="n">gmask</span> <span class="o">=</span> <span class="n">val</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">val</span> <span class="o">+</span> <span class="mf">3.5</span>
    <span class="n">bmask</span> <span class="o">=</span> <span class="n">val</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">val</span> <span class="o">+</span> <span class="mf">2.5</span>
    <span class="n">r</span>     <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">-</span> <span class="mf">1.5</span><span class="p">)</span><span class="o">*</span><span class="n">rmask</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="n">val</span> <span class="o">+</span> <span class="mf">4.5</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">rmask</span><span class="p">)</span>
    <span class="n">g</span>     <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">gmask</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="n">val</span> <span class="o">+</span> <span class="mf">3.5</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">gmask</span><span class="p">)</span>
    <span class="n">b</span>     <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">bmask</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="n">val</span> <span class="o">+</span> <span class="mf">2.5</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">bmask</span><span class="p">)</span>
    
    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">r</span><span class="p">,</span><span class="n">g</span><span class="p">,</span><span class="n">b</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">saturationIndicator</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&quot;i,ij-&gt;ij&quot;</span><span class="p">,((</span><span class="n">val</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)),</span><span class="n">result</span><span class="p">)</span><span class="o">+</span>
                  <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&quot;i,j-&gt;ij&quot;</span><span class="p">,</span> <span class="p">((</span><span class="n">val</span>  <span class="o">&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">val</span>  <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)),[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">result</span> 
</div>
<div class="viewcode-block" id="metersToRGB"><a class="viewcode-back" href="../../metersToRGB.html#pyvsim.Utils.metersToRGB">[docs]</a><span class="k">def</span> <span class="nf">metersToRGB</span><span class="p">(</span><span class="n">wl</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts light wavelength to a RGB vector, the algorithm comes from:</span>
<span class="sd">    `This blog &lt;http://codingmess.blogspot.de/2009/05/conversion-of-wavelength-in-nanometers.html&gt;`_</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    wl : scalar</span>
<span class="sd">        The wavelength in meters</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    [R,G,B] : numpy.array (3)</span>
<span class="sd">        The normalized (0..1) RGB value for this wavelength</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">gamma</span> <span class="o">=</span> <span class="mf">0.8</span>
    <span class="n">wl</span> <span class="o">=</span> <span class="n">wl</span> <span class="o">*</span> <span class="mf">1e9</span>
    <span class="n">f</span> <span class="o">=</span><span class="p">((</span><span class="n">wl</span> <span class="o">&gt;=</span> <span class="mi">380</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">wl</span> <span class="o">&lt;</span> <span class="mi">420</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">0.3</span> <span class="o">+</span> <span class="mf">0.7</span> <span class="o">*</span> <span class="p">(</span><span class="n">wl</span> <span class="o">-</span> <span class="mi">380</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">420</span> <span class="o">-</span> <span class="mi">380</span><span class="p">))</span> <span class="o">+</span> 
        <span class="p">(</span><span class="n">wl</span> <span class="o">&gt;=</span> <span class="mi">420</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">wl</span> <span class="o">&lt;</span> <span class="mi">700</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1</span> <span class="o">+</span> 
        <span class="p">(</span><span class="n">wl</span> <span class="o">&gt;=</span> <span class="mi">700</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">wl</span> <span class="o">&lt;</span> <span class="mi">780</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mf">0.7</span> <span class="o">*</span> <span class="p">(</span><span class="n">wl</span> <span class="o">-</span> <span class="mi">700</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">780</span> <span class="o">-</span> <span class="mi">700</span><span class="p">)))</span>
        
    <span class="n">r</span> <span class="o">=</span><span class="p">((</span><span class="n">wl</span> <span class="o">&lt;</span> <span class="mi">475</span><span class="p">)</span>  <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">wl</span> <span class="o">-</span> <span class="mi">380</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">440</span> <span class="o">-</span> <span class="mi">380</span><span class="p">))</span> <span class="o">+</span> 
        <span class="p">(</span><span class="n">wl</span> <span class="o">&gt;=</span> <span class="mi">475</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">wl</span> <span class="o">-</span> <span class="mi">510</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">580</span> <span class="o">-</span> <span class="mi">510</span><span class="p">)))</span>
    
    <span class="n">g</span> <span class="o">=</span><span class="p">((</span><span class="n">wl</span> <span class="o">&lt;</span> <span class="mi">535</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">wl</span> <span class="o">-</span> <span class="mi">440</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">490</span> <span class="o">-</span> <span class="mi">440</span><span class="p">))</span> <span class="o">+</span> 
        <span class="p">(</span><span class="n">wl</span> <span class="o">&gt;=</span> <span class="mi">535</span><span class="p">)</span><span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">wl</span> <span class="o">-</span> <span class="mi">580</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">645</span> <span class="o">-</span> <span class="mi">580</span><span class="p">)))</span>
    
    <span class="n">b</span> <span class="o">=</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">wl</span> <span class="o">-</span> <span class="mi">490</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">510</span> <span class="o">-</span> <span class="mi">490</span><span class="p">))</span>
    
    <span class="k">return</span> <span class="p">(((</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">([</span><span class="n">r</span><span class="p">,</span><span class="n">g</span><span class="p">,</span><span class="n">b</span><span class="p">],</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">*</span><span class="n">f</span><span class="p">)</span><span class="o">**</span><span class="n">gamma</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="aeq"><a class="viewcode-back" href="../../aeq.html#pyvsim.Utils.aeq">[docs]</a><span class="k">def</span> <span class="nf">aeq</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A tool for comparing numpy ndarrays and checking if all their values</span>
<span class="sd">    are Almost EQual up to a given tolerance.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a,b : numpy.arrays or scalars</span>
<span class="sd">        Values to be compared, must have the same size</span>
<span class="sd">    tol = 1e-8</span>
<span class="sd">        The tolerance of the comparison</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    True, False</span>
<span class="sd">        Depending if the absolute difference between of one of the values of</span>
<span class="sd">        the inputs exceeds the tolerance</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; aeq(0,0.00000000000001)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; aeq(np.array([1,0,0]),np.array([0.99999999999999,0,0]))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; aeq(np.array([1,0,0]),np.array([0.99999,0,0]))</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tol</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="n">temp</span> <span class="o">==</span> <span class="bp">True</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
    <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">temp</span>
       </div>
<div class="viewcode-block" id="reallocateArray"><a class="viewcode-back" href="../../reallocateArray.html#pyvsim.Utils.reallocateArray">[docs]</a><span class="k">def</span> <span class="nf">reallocateArray</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">extrasteps</span><span class="p">):</span>
    <span class="n">size</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">array</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">extrasteps</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">array</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
        <span class="n">size</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">array</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">temp</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">array</span><span class="p">,</span><span class="mi">0</span><span class="p">))]</span> <span class="o">=</span> <span class="n">array</span>
    <span class="k">return</span> <span class="n">temp</span>
               </div>
<div class="viewcode-block" id="rotateVector"><a class="viewcode-back" href="../../rotateVector.html#pyvsim.Utils.rotateVector">[docs]</a><span class="k">def</span> <span class="nf">rotateVector</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">angle</span><span class="p">,</span><span class="n">axis</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This implementation uses angles in degrees. The algorithm is the vectorized</span>
<span class="sd">    formulation of the `Euler-Rodrigues formula </span>
<span class="sd">    &lt;http://en.wikipedia.org/wiki/Euler%E2%80%93Rodrigues_parameters&gt;`_</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : numpy.array (N, 3)</span>
<span class="sd">        A vector or a list of vectors (N rows, 3 columns) to be</span>
<span class="sd">        rotated</span>
<span class="sd">    angle : double</span>
<span class="sd">        scalar (in radians)</span>
<span class="sd">    axis : numpy.array (3)</span>
<span class="sd">        A vector around which the vector is rotated</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    vectors : numpy.array (N, 3)</span>
<span class="sd">        The vectors after rotation</span>
<span class="sd">        </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; [x,y,z] = np.eye(3)</span>
<span class="sd">    &gt;&gt;&gt; temp = rotateVector(x, np.pi/2, z)</span>
<span class="sd">    &gt;&gt;&gt; aeq(temp, y)</span>
<span class="sd">    True</span>
<span class="sd">    </span>
<span class="sd">    This works also for lists of vectors::</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; X = np.tile(x,(100,1))</span>
<span class="sd">    &gt;&gt;&gt; Y = np.tile(y,(100,1))</span>
<span class="sd">    &gt;&gt;&gt; Z = np.tile(z,(100,1))</span>
<span class="sd">    &gt;&gt;&gt; temp = rotateVector(X, np.pi/2, Z)</span>
<span class="sd">    &gt;&gt;&gt; aeq(temp, Y)</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">axis</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span><span class="mi">0</span><span class="p">):</span>
            <span class="n">angle</span> <span class="o">=</span> <span class="n">angle</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span><span class="mi">0</span><span class="p">)))</span>
            <span class="n">a</span>     <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&quot;ij,i-&gt;ij&quot;</span><span class="p">,</span><span class="n">axis</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&quot;i,ij-&gt;ij&quot;</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">x</span><span class="p">))</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">x</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">axis</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">x</span><span class="p">))</span>
    </div>
<div class="viewcode-block" id="rotatePoints"><a class="viewcode-back" href="../../rotatePoints.html#pyvsim.Utils.rotatePoints">[docs]</a><span class="k">def</span> <span class="nf">rotatePoints</span><span class="p">(</span><span class="n">points</span><span class="p">,</span><span class="n">angle</span><span class="p">,</span><span class="n">axis</span><span class="p">,</span><span class="n">origin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrap-around `Euler-Rodrigues formula </span>
<span class="sd">    &lt;http://en.wikipedia.org/wiki/Euler%E2%80%93Rodrigues_parameters&gt;`_</span>
<span class="sd">    formula for rotating a point cloud</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    points : numpy.array (N, 3)</span>
<span class="sd">        A point (size = 3) or a list of points (N rows, 3 columns) to be</span>
<span class="sd">        rotated</span>
<span class="sd">    angle : scalar</span>
<span class="sd">        scalar (in radians)</span>
<span class="sd">    axis : numpy.array (3)</span>
<span class="sd">        A vector around which the points are rotated</span>
<span class="sd">    origin : numpy.array (3)</span>
<span class="sd">        A point around which the points are rotated</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    points : numpy.array (N, 3)</span>
<span class="sd">        A list of rotated points</span>
<span class="sd">        </span>
<span class="sd">    Examples</span>
<span class="sd">    --------    </span>
<span class="sd">    &gt;&gt;&gt; o = np.array([0,0,0])</span>
<span class="sd">    &gt;&gt;&gt; [x,y,z] = np.eye(3)</span>
<span class="sd">    &gt;&gt;&gt; temp = rotatePoints(x, np.pi/2, z, o)</span>
<span class="sd">    &gt;&gt;&gt; aeq(temp, y)</span>
<span class="sd">    True</span>
<span class="sd">    </span>
<span class="sd">    This works also for lists of vectors::</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; X = np.tile(x,(100,1))</span>
<span class="sd">    &gt;&gt;&gt; Y = np.tile(y,(100,1))</span>
<span class="sd">    &gt;&gt;&gt; Z = np.tile(z,(100,1))</span>
<span class="sd">    &gt;&gt;&gt; temp = rotatePoints(X, np.pi/2, Z, o)</span>
<span class="sd">    &gt;&gt;&gt; aeq(temp, Y)</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">rotateVector</span><span class="p">(</span><span class="n">points</span><span class="o">-</span><span class="n">origin</span><span class="p">,</span><span class="n">angle</span><span class="p">,</span><span class="n">axis</span><span class="p">)</span> <span class="o">+</span> <span class="n">origin</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">points</span>
        </div>
<div class="viewcode-block" id="normalize"><a class="viewcode-back" href="../../normalize.html#pyvsim.Utils.normalize">[docs]</a><span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="n">vectors</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This can be used to normalize a vector or a list of vectors, provided</span>
<span class="sd">    they are given as numpy arrays.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    vectors : numpy.array (N, 3)</span>
<span class="sd">        A list of vectors to be normalized</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    vectors : numpy.array (N, 3)</span>
<span class="sd">        The normalized vectors</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------    </span>
<span class="sd">    &gt;&gt;&gt; result = normalize(np.array([2,0,0]))</span>
<span class="sd">    &gt;&gt;&gt; assert(aeq(result, np.array([1,0,0])))</span>
<span class="sd">    </span>
<span class="sd">    And for multiple vectors:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; result = normalize(np.array([[2,0,0], </span>
<span class="sd">    ...                              [0,0,1]]))</span>
<span class="sd">    &gt;&gt;&gt; assert(aeq(result, np.array([[1,0,0], </span>
<span class="sd">    ...                              [0,0,1]])))</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">vectors</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">vectors</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vectors</span><span class="p">,</span><span class="n">vectors</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
    <span class="k">if</span> <span class="n">vectors</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">ncols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">vectors</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">norms</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">vectors</span><span class="p">)</span>
        <span class="n">norms</span><span class="p">[</span><span class="n">norms</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">norms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">norms</span><span class="o">.</span><span class="n">T</span><span class="p">,(</span><span class="n">ncols</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="k">return</span> <span class="n">vectors</span> <span class="o">/</span> <span class="n">norms</span>
        </div>
<div class="viewcode-block" id="norm"><a class="viewcode-back" href="../../norm.html#pyvsim.Utils.norm">[docs]</a><span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="n">vectors</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This can be used to calculate the euclidean norm of vector or a list of </span>
<span class="sd">    vectors, provided they are given as numpy arrays.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    vectors : numpy.array (N, 3)</span>
<span class="sd">        A list of vectors</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    norms : numpy.array (N)</span>
<span class="sd">        A list with the euclidean norm of the vectors</span>
<span class="sd">        </span>
<span class="sd">    Examples</span>
<span class="sd">    --------    </span>
<span class="sd">    &gt;&gt;&gt; inp = norm(np.array([1,1,0]))</span>
<span class="sd">    &gt;&gt;&gt; out = np.sqrt(2)</span>
<span class="sd">    &gt;&gt;&gt; assert(aeq(inp, out))</span>
<span class="sd">    </span>
<span class="sd">    And for multiple vectors:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; inp = norm(np.array([[1,1,0],</span>
<span class="sd">    ...                      [1,1,1]]))</span>
<span class="sd">    &gt;&gt;&gt; out = np.array([np.sqrt(2), </span>
<span class="sd">    ...                 np.sqrt(3)])</span>
<span class="sd">    &gt;&gt;&gt; assert(aeq(inp, out))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">vectors</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vectors</span><span class="p">,</span><span class="n">vectors</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
    <span class="k">if</span> <span class="n">vectors</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">vectors</span><span class="o">*</span><span class="n">vectors</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
       </div>
<div class="viewcode-block" id="barycentricCoordinates"><a class="viewcode-back" href="../../barycentricCoordinates.html#pyvsim.Utils.barycentricCoordinates">[docs]</a><span class="k">def</span> <span class="nf">barycentricCoordinates</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">,</span><span class="n">p3</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the barycentric coordinates of points, given the triangles where</span>
<span class="sd">    they belong. </span>
<span class="sd">    </span>
<span class="sd">    For more information on barycentric coordinates, see `Wikipedia </span>
<span class="sd">    &lt;http://en.wikipedia.org/wiki/Barycentric_coordinate_system&gt;`_</span>
<span class="sd">    </span>
<span class="sd">    Assumes::</span>
<span class="sd">    1) points are given as numpy arrays (crashes if not met)</span>
<span class="sd">    </span>
<span class="sd">    Algorithm</span>
<span class="sd">    ---------</span>
<span class="sd">    area        = Object.triangleArea(p1,p2,p3)</span>
<span class="sd">    lambda1     = Object.triangleArea(p,p2,p3)</span>
<span class="sd">    lambda2     = Object.triangleArea(p,p1,p3)</span>
<span class="sd">    lambda3     = Object.triangleArea(p,p1,p2)</span>
<span class="sd">    return np.array([lambda1,lambda2,lambda3])/area</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    p</span>
<span class="sd">        point in space, or a list of points in space</span>
<span class="sd">    p1,p2,p3 </span>
<span class="sd">        points space representing triangle (can be lists)</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    [lambda1,lambda2,lambda3]</span>
<span class="sd">        the barycentric coordinates of point p with respect to the defined </span>
<span class="sd">        triangle</span>
<span class="sd">        </span>
<span class="sd">    Examples</span>
<span class="sd">    --------   </span>
<span class="sd">    &gt;&gt;&gt; [p,p1,p2,p3] = np.array([[0.5,0.5, 0],</span>
<span class="sd">    ...                          [  0,  0, 0],</span>
<span class="sd">    ...                          [  1,  0, 0],</span>
<span class="sd">    ...                          [  0,  1, 0]])</span>
<span class="sd">    &gt;&gt;&gt; barycentricCoordinates(p,p1,p2,p3)</span>
<span class="sd">    array([ 0. ,  0.5,  0.5])</span>
<span class="sd">    </span>
<span class="sd">    Will also work for arrays::</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; p  = np.tile(p,(3,1));  p1 = np.tile(p1,(3,1))</span>
<span class="sd">    &gt;&gt;&gt; p2 = np.tile(p2,(3,1)); p3 = np.tile(p3,(3,1))</span>
<span class="sd">    &gt;&gt;&gt; barycentricCoordinates(p,p1,p2,p3)</span>
<span class="sd">    array([[ 0. ,  0.5,  0.5],</span>
<span class="sd">           [ 0. ,  0.5,  0.5],</span>
<span class="sd">           [ 0. ,  0.5,  0.5]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">area</span>        <span class="o">=</span> <span class="n">triangleArea</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">,</span><span class="n">p3</span><span class="p">)</span>
    <span class="n">lambda1</span>     <span class="o">=</span> <span class="n">triangleArea</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">p2</span><span class="p">,</span><span class="n">p3</span><span class="p">)</span>
    <span class="n">lambda2</span>     <span class="o">=</span> <span class="n">triangleArea</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">p1</span><span class="p">,</span><span class="n">p3</span><span class="p">)</span>
    <span class="n">lambda3</span>     <span class="o">=</span> <span class="n">triangleArea</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">p1</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">lambda1</span><span class="p">,</span><span class="n">lambda2</span><span class="p">,</span><span class="n">lambda3</span><span class="p">])</span><span class="o">/</span><span class="n">area</span>
    <span class="k">if</span> <span class="n">p1</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">lambda1</span><span class="p">,</span><span class="n">lambda2</span><span class="p">,</span><span class="n">lambda3</span><span class="p">])</span> <span class="o">/</span> <span class="n">area</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>       
   </div>
<div class="viewcode-block" id="triangleArea"><a class="viewcode-back" href="../../triangleArea.html#pyvsim.Utils.triangleArea">[docs]</a><span class="k">def</span> <span class="nf">triangleArea</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">,</span><span class="n">p3</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given three points in 3D space, returns the triangle area. </span>
<span class="sd">    </span>
<span class="sd">    Assumes:</span>
<span class="sd">    </span>
<span class="sd">    1. points are given as numpy arrays (crashes if not met)</span>
<span class="sd">    2. if points lists are given, this will still work</span>
<span class="sd">    </span>
<span class="sd">    Algorithm</span>
<span class="sd">    ---------</span>
<span class="sd">    .. math::</span>
<span class="sd">        \\vec{V}_1 = \\vec{P}_2 - \\vec{P}_1</span>
<span class="sd">        </span>
<span class="sd">        \\vec{V}_2 = \\vec{P}_3 - \\vec{P}_1</span>
<span class="sd">        </span>
<span class="sd">        A = {1 \\over 2} \\overline{\\vec{V}_1 \\times \\vec{V}_2}</span>
<span class="sd">        </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    p1, p2, p3 : numpy.array</span>
<span class="sd">        If a list of points is given, they must be vertically stacked.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    area : scalar / numpy.array</span>
<span class="sd">        The area of the points defined by the triangles. If lists of points</span>
<span class="sd">        were used as inputs, the output is a 1D numpy.array with as many</span>
<span class="sd">        elements as given points </span>
<span class="sd">    &quot;&quot;&quot;</span> 
    <span class="n">v1</span> <span class="o">=</span> <span class="n">p2</span> <span class="o">-</span> <span class="n">p1</span>
    <span class="n">v2</span> <span class="o">=</span> <span class="n">p3</span> <span class="o">-</span> <span class="n">p1</span>
    <span class="k">return</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">))</span>
      </div>
<div class="viewcode-block" id="KQ"><a class="viewcode-back" href="../../KQ.html#pyvsim.Utils.KQ">[docs]</a><span class="k">def</span> <span class="nf">KQ</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This decomposition is proposed in the book &quot;Multiple View Geometry in</span>
<span class="sd">    computer vision&quot; by Hartley and Zisserman. It is basically a RQ </span>
<span class="sd">    decomposition (which takes a matrix :math:`M` and finds a right, upper diagonal</span>
<span class="sd">    camera matrix :math:`K` and a orthogonal matrix :math:`Q` so that :math:`M = aKQ` (:math:`a` </span>
<span class="sd">    is a normalizing factor (:math:`R[-1,-1]`)).</span>
<span class="sd">    </span>
<span class="sd">    This specific function has the following extra steps: </span>
<span class="sd">    </span>
<span class="sd">    1) it defines a diagonal matrix :math:`D` which, when post-multiplied by </span>
<span class="sd">    :math:`K` makes </span>
<span class="sd">    its diagonal elements positive.</span>
<span class="sd">     </span>
<span class="sd">    2) it normalizes :math:`K` by its :math:`[-1,-1]` element.</span>
<span class="sd">    </span>
<span class="sd">    The use of these steps is that when the matrix :math:`M` is a DLT matrix, </span>
<span class="sd">    :math:`K` is a camera matrix, and :math:`Q` is the orientation of the </span>
<span class="sd">    camera (its rows are the front, down and left vectors, respectively).</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A : numpy.array</span>
<span class="sd">        A square matrix. *Attention*, DLT matrices need to have their last</span>
<span class="sd">        column taken away for this procedure.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    K : numpy.array</span>
<span class="sd">        The camera matrix, normalized by its :math:`[-1,-1]` element.</span>
<span class="sd">    Q : numpy.array</span>
<span class="sd">        The camera orientation matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">R</span><span class="p">,</span> <span class="n">Q</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">rq</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">R</span><span class="p">)))</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="n">D</span><span class="p">)</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">D</span><span class="p">,</span><span class="n">Q</span><span class="p">)</span> <span class="c">#D^-1 = D     </span>
<span class="c">#    print &quot;K\n&quot;, K</span>
<span class="c">#    print &quot;D\n&quot;, D</span>
<span class="c">#    print &quot;Q\n&quot;, Q</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">[:,:</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="n">Q</span><span class="p">)))</span> <span class="o">&gt;</span> <span class="mf">1e-10</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;WARNING - KQ decomposition failed, residue: </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">A</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="n">Q</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">K</span> <span class="o">/</span> <span class="n">K</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">Q</span>
</div>
<div class="viewcode-block" id="pointSegmentDistance"><a class="viewcode-back" href="../../pointSegmentDistance.html#pyvsim.Utils.pointSegmentDistance">[docs]</a><span class="k">def</span> <span class="nf">pointSegmentDistance</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given one point and some line segments, calculates the euclidean distance</span>
<span class="sd">    between each segment and this point.</span>
<span class="sd">    </span>
<span class="sd">    If the point lies outside segment, returns the distance between point and</span>
<span class="sd">    nearest extremity of the segment    </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    p1 : numpy.array (N,3)</span>
<span class="sd">        Coordinates of segments&#39; initial points</span>
<span class="sd">    p2 : numpy.array (N,3)</span>
<span class="sd">        Coordinates of segments&#39; final points</span>
<span class="sd">    x : numpy.array(3)</span>
<span class="sd">        Coordinates of point</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    distance : numpy.array (N)</span>
<span class="sd">        Distance between each of the segments and the point</span>
<span class="sd">        </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; p1 = np.array([[  0,  0, 0],</span>
<span class="sd">    ...                [  0,  0, 0],</span>
<span class="sd">    ...                [  0,  0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; p2 = np.array([[  1,  0, 0],</span>
<span class="sd">    ...                [  0,  1, 0],</span>
<span class="sd">    ...                [  0,  0, 1]])  </span>
<span class="sd">    &gt;&gt;&gt; x  = np.array([  1,  1, 1])</span>
<span class="sd">    &gt;&gt;&gt; pointSegmentDistance(p1, p2, x)</span>
<span class="sd">    array([ 1.41421356,  1.41421356,  1.41421356])</span>
<span class="sd">    &gt;&gt;&gt; x  = np.array([  2,  0, 0])</span>
<span class="sd">    &gt;&gt;&gt; pointSegmentDistance(p1, p2, x)</span>
<span class="sd">    array([ 1.,  2.,  2.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">v</span>    <span class="o">=</span> <span class="p">(</span><span class="n">p2</span> <span class="o">-</span> <span class="n">p1</span><span class="p">)</span> 
    <span class="n">vlen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="n">v</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">vlen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">vlen</span><span class="p">)</span><span class="o">*</span><span class="mi">1000</span>
    <span class="n">v</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&quot;ij,i-&gt;ij&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">vlen</span><span class="p">)</span>
    <span class="c"># Calculate vectors from segment extremities to point</span>
    <span class="n">p1x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">p1</span>
    <span class="n">p2x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">p2</span>
    <span class="c"># Calculate point-line (not segment) distance</span>
    <span class="n">d_v_x</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">p1x</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
    <span class="n">d_v_x</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">d_v_x</span><span class="o">*</span><span class="n">d_v_x</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    <span class="c"># Calculate the projection of the point p at the line</span>
    <span class="n">p1_x_prime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p1x</span><span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">p2_x_prime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p2x</span><span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">insegment</span>  <span class="o">=</span> <span class="n">aeq</span><span class="p">(</span><span class="n">p1_x_prime</span> <span class="o">+</span> <span class="n">p2_x_prime</span><span class="p">,</span> <span class="n">vlen</span><span class="p">)</span> 
    <span class="c"># Calculate point-point distances</span>
    <span class="n">d_p1_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p1x</span><span class="o">*</span><span class="n">p1x</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">d_p2_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p2x</span><span class="o">*</span><span class="n">p2x</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">d_extrem</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">d_p1_x</span><span class="p">,</span><span class="n">d_p2_x</span><span class="p">]),</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">d_v_x</span><span class="o">*</span><span class="n">insegment</span> <span class="o">+</span> <span class="n">d_extrem</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">insegment</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="linesIntersection"><a class="viewcode-back" href="../../linesIntersection.html#pyvsim.Utils.linesIntersection">[docs]</a><span class="k">def</span> <span class="nf">linesIntersection</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">p</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the intersection of a list of lines. If no intersection exists,</span>
<span class="sd">    will return a point that minimizes the square of the distances to the</span>
<span class="sd">    given lines.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : numpy.array (N, M)</span>
<span class="sd">        A list of vectors with the direction of the lines (for 3D vectors, </span>
<span class="sd">        M = 3)</span>
<span class="sd">    p : numpy.array (N, M)</span>
<span class="sd">        A list of vectors with a point in the line</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x : numpy.array (M)</span>
<span class="sd">        The point that minimizes the square of the distance to each line</span>
<span class="sd">        </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    numpy.linalg.LinAlgError</span>
<span class="sd">        If the given lines are almost parallel, so no unique solution can be</span>
<span class="sd">        found</span>
<span class="sd">        </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; v = np.array([[1,0,0],</span>
<span class="sd">    ...               [0,1,0]])</span>
<span class="sd">    &gt;&gt;&gt; p = np.array([[0,0,0],</span>
<span class="sd">    ...               [0,-1,0]])</span>
<span class="sd">    &gt;&gt;&gt; linesIntersection(v,p)</span>
<span class="sd">    array([ 0.,  0.,  0.])</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; p = np.array([[0,0,0],[0,-1,0.1]]) # No intersection exists</span>
<span class="sd">    &gt;&gt;&gt; linesIntersection(v,p)</span>
<span class="sd">    array([ 0.  ,  0.  ,  0.05])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">nlines</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">NN</span>      <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nlines</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">NNp</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nlines</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nlines</span><span class="p">):</span>
        <span class="n">NN</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="p">],(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)),</span> 
                                    <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="p">],(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)))</span>
        <span class="n">NNp</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">NN</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">n</span><span class="p">],(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)))</span> 
        
    <span class="n">part1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">NN</span><span class="p">,</span>  <span class="mi">0</span><span class="p">)</span>
    <span class="n">part2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">NNp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        
    <span class="p">[</span><span class="n">U</span><span class="p">,</span><span class="n">D</span><span class="p">,</span><span class="n">V</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">part1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">D</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">D</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">1e10</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">(</span><span class="s">&quot;Could not converge calculation&quot;</span><span class="p">)</span>
    
    <span class="n">part1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">D</span><span class="p">),</span> <span class="n">U</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
    
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">part1</span><span class="p">,</span><span class="n">part2</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="readSTL"><a class="viewcode-back" href="../../readSTL.html#pyvsim.Utils.readSTL">[docs]</a><span class="k">def</span> <span class="nf">readSTL</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;&quot;</span>
<span class="sd">    Reads an STL file and converts it into a pyvsim Part. Note that the </span>
<span class="sd">    coordinate system of the STL file is used for the pyvsim Part.</span>
<span class="sd">    </span>
<span class="sd">    This function uses the facilities of VTK for STL reading. Sometimes this</span>
<span class="sd">    causes a warning window to pop-up, but most of times the files are read</span>
<span class="sd">    successfully.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filename : string</span>
<span class="sd">        The filename (including path) of the stl file.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    part : pyvsim.Primitives.Part</span>
<span class="sd">        A part with the STL data. With the following default parameters:</span>
<span class="sd">        </span>
<span class="sd">        * name : the Part name is the filename</span>
<span class="sd">        * surfaceProperty : opaque</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">vtk</span>
    <span class="kn">import</span> <span class="nn">pyvsim.Primitives</span>
    <span class="n">STLReader</span>   <span class="o">=</span> <span class="n">vtk</span><span class="o">.</span><span class="n">vtkSTLReader</span><span class="p">()</span>

    <span class="n">STLReader</span><span class="o">.</span><span class="n">SetFileName</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="n">STLReader</span><span class="o">.</span><span class="n">Update</span><span class="p">()</span>
    <span class="n">polydata</span> <span class="o">=</span> <span class="n">STLReader</span><span class="o">.</span><span class="n">GetOutput</span><span class="p">()</span>    
    <span class="n">points</span>      <span class="o">=</span> <span class="n">polydata</span><span class="o">.</span><span class="n">GetPoints</span><span class="p">()</span>
   
    <span class="n">pts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">points</span><span class="o">.</span><span class="n">GetNumberOfPoints</span><span class="p">()):</span>
        <span class="n">pts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">points</span><span class="o">.</span><span class="n">GetPoint</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
   
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">polydata</span><span class="o">.</span><span class="n">GetNumberOfCells</span><span class="p">()):</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">vtk</span><span class="o">.</span><span class="n">vtkIdList</span><span class="p">()</span>
        <span class="n">polydata</span><span class="o">.</span><span class="n">GetCellPoints</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">temp</span><span class="p">)</span>
        <span class="n">cts</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">temp</span><span class="o">.</span><span class="n">GetId</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">temp</span><span class="o">.</span><span class="n">GetId</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">temp</span><span class="o">.</span><span class="n">GetId</span><span class="p">(</span><span class="mi">2</span><span class="p">)])</span>
       
    <span class="n">obj</span>                 <span class="o">=</span> <span class="n">pyvsim</span><span class="o">.</span><span class="n">Primitives</span><span class="o">.</span><span class="n">Part</span><span class="p">()</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">points</span>          <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">connectivity</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cts</span><span class="p">)</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">name</span>            <span class="o">=</span> <span class="n">filename</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">surfaceProperty</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">OPAQUE</span>
    
    <span class="k">print</span> <span class="s">&quot;Read </span><span class="si">%i</span><span class="s"> triangles&quot;</span> <span class="o">%</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">cts</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">obj</span>
</div>
<div class="viewcode-block" id="DLT"><a class="viewcode-back" href="../../DLT.html#pyvsim.Utils.DLT">[docs]</a><span class="k">def</span> <span class="nf">DLT</span><span class="p">(</span><span class="n">uvlist</span><span class="p">,</span> <span class="n">xyzlist</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function calculates the direct linear transform matrix, which is the</span>
<span class="sd">    transform executed by a pinhole camera. This procedure was suggested in</span>
<span class="sd">    `Wikipedia &lt;http://en.wikipedia.org/wiki/Direct_linear_transformation&gt;`_ </span>
<span class="sd">    and some refinements are discussed in the book &quot;Multiple View Geometry in</span>
<span class="sd">    computer vision&quot; by Hartley and Zisserman.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    uvlist : numpy.array</span>
<span class="sd">        A (N,2) matrix containing points at the sensor coordinates</span>
<span class="sd">    xyzlist: numpy.array</span>
<span class="sd">        A (N,3) matrix containing points at the world coordinates</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    M : numpy.array (3x4)</span>
<span class="sd">        A matrix with the transformation to be used with homogeneous</span>
<span class="sd">        coordinates. The matrix M is normalized by the norm of the elements</span>
<span class="sd">        M(2,0:3), because then the depth of points is automatically given as</span>
<span class="sd">        the third (the homogeneous) coordinate.</span>
<span class="sd">    dMdX : numpy.array</span>
<span class="sd">        A matrix containing the factors to calculate the partial derivatives</span>
<span class="sd">        of the UV coordinates with respect to the XYZ coordinates. By </span>
<span class="sd">        multiplying dMdX * M * XYZ1, one gets the derivatives in the following</span>
<span class="sd">        order </span>
<span class="sd">        :math:`\\left [ {\\partial u \\over \\partial x} </span>
<span class="sd">        {\\partial u \\over \\partial y}</span>
<span class="sd">        {\\partial u \\over \\partial z}</span>
<span class="sd">        {\\partial v \\over \\partial x}</span>
<span class="sd">        {\\partial v \\over \\partial y}</span>
<span class="sd">        {\\partial v \\over \\partial z} \\right ]` </span>
<span class="sd">        multiplied by :math:`w^2` (which,</span>
<span class="sd">        for the normalized matrix :math:`M`, is the depth of the points)</span>
<span class="sd">    detM : scalar</span>
<span class="sd">        The determinant of the matrix formed by the first three columns of </span>
<span class="sd">        :math:`M`,</span>
<span class="sd">        if :math:`det(M[:,:3]) &lt; 0`, it indicates that the mapping is done from a</span>
<span class="sd">        right-handed coordinate system to a left-handed one (or vice versa). </span>
<span class="sd">        This case happens when doing a mapping with a odd number of mirrors</span>
<span class="sd">        between camera and mapped region, and some derived quantities must be</span>
<span class="sd">        inverted in this case, e.g. the line-of-sight vector.</span>
<span class="sd">    condition_number : double</span>
<span class="sd">        The condition number stated in page 108 of Hartley and Zisseman, which</span>
<span class="sd">        is the ratio of the first and the second-last singular value (because</span>
<span class="sd">        the last should be zero, if the transform is perfect. According to</span>
<span class="sd">        `Wikipedia &lt;http://en.wikipedia.org/wiki/Condition_number&gt;`_, the </span>
<span class="sd">        :math:`log_{10}` of the condition number gives roughly how many digits of </span>
<span class="sd">        accuracy are lost by transforming using the given matrix.</span>
<span class="sd">    last_singular_value: double</span>
<span class="sd">        The smallest singular value. The finding of the DLT matrix is a </span>
<span class="sd">        minimization of the problem </span>
<span class="sd">        :math:`\\left | Ax \\right |` with :math:`\\left | x \\right | = 1`. </span>
<span class="sd">        last_condition_number is exactly abs(A*x), and gives an idea of the</span>
<span class="sd">        precision of the matrix found (with :math:`0` being perfect)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">uvlist</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>  <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">xyzlist</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">uvlist</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>  <span class="o">==</span> <span class="mi">2</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">xyzlist</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
    
    <span class="p">[</span><span class="n">uv</span><span class="p">,</span>  <span class="n">Tuv</span><span class="p">]</span>  <span class="o">=</span> <span class="n">DLTnormalization</span><span class="p">(</span><span class="n">uvlist</span><span class="p">)</span>
    <span class="p">[</span><span class="n">xyz</span><span class="p">,</span> <span class="n">Txyz</span><span class="p">]</span> <span class="o">=</span> <span class="n">DLTnormalization</span><span class="p">(</span><span class="n">xyzlist</span><span class="p">)</span>
    
    <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">xyzlist</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span><span class="p">,</span><span class="mi">12</span><span class="p">))</span>
    
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">uvlist</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
        <span class="n">xyz1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">xyz</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">u</span>    <span class="o">=</span> <span class="n">uv</span><span class="p">[</span><span class="n">n</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">v</span>    <span class="o">=</span> <span class="n">uv</span><span class="p">[</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">w</span>    <span class="o">=</span> <span class="mi">1</span>
        <span class="n">matrix</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">n</span><span class="p">,:]</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span> <span class="mi">0</span><span class="o">*</span><span class="n">xyz1</span><span class="p">,</span> <span class="n">w</span><span class="o">*</span><span class="n">xyz1</span><span class="p">,</span>   <span class="o">-</span><span class="n">v</span><span class="o">*</span><span class="n">xyz1</span><span class="p">])</span>
        <span class="n">matrix</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="o">-</span><span class="n">w</span><span class="o">*</span><span class="n">xyz1</span><span class="p">,</span> <span class="mi">0</span><span class="o">*</span><span class="n">xyz1</span><span class="p">,</span>    <span class="n">u</span><span class="o">*</span><span class="n">xyz1</span><span class="p">])</span>
        <span class="n">matrix</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span> <span class="n">v</span><span class="o">*</span><span class="n">xyz1</span><span class="p">,</span><span class="o">-</span><span class="n">u</span><span class="o">*</span><span class="n">xyz1</span><span class="p">,</span>    <span class="mi">0</span><span class="o">*</span><span class="n">xyz1</span><span class="p">])</span>
        
    <span class="p">[</span><span class="n">_</span><span class="p">,</span><span class="n">D</span><span class="p">,</span><span class="n">V</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">V</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c">#takes last vector</span>

<span class="c">#    # Remember the fact that the points are in front of the camera</span>
    <span class="k">if</span> <span class="n">V</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">V</span> <span class="o">=</span> <span class="o">-</span><span class="n">V</span>
        
<span class="c">#    print &quot;Minimum singular value&quot;, D[-1]</span>

    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">Tuv</span><span class="p">),</span> 
               <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">V</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">],</span><span class="n">V</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">8</span><span class="p">],</span><span class="n">V</span><span class="p">[</span><span class="mi">8</span><span class="p">:</span><span class="mi">12</span><span class="p">]]),</span> <span class="n">Txyz</span><span class="p">))</span>
 
<span class="c">#    print &quot;Check&quot;</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">uvlist</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
        <span class="n">uv</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">uvlist</span><span class="p">[</span><span class="n">n</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>   <span class="n">uvlist</span><span class="p">[</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xyzlist</span><span class="p">[</span><span class="n">n</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">xyzlist</span><span class="p">[</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">xyzlist</span><span class="p">[</span><span class="n">n</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">xyz</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">uv</span> <span class="o">-</span> <span class="n">ans</span> <span class="o">/</span> <span class="n">ans</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span> <span class="o">&gt;</span> <span class="mf">1e-3</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Discrepancy of more than 1e-3 found in DLT&quot;</span><span class="p">,</span> <span class="ne">Warning</span><span class="p">)</span>

    <span class="c"># This normalization is applied so that the third element of the resulting</span>
    <span class="c"># UV-vector is the distance from the XYZ-point to the center of projection </span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">M</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="p">,:</span><span class="mi">3</span><span class="p">])</span>

    <span class="c"># This matrix provides the derivatives of the UV-coordinates with respect</span>
    <span class="c"># to the XYZ coordinates</span>
    <span class="c">#                        / dU/dx \</span>
    <span class="c">#                        | dU/dy |</span>
    <span class="c">#                        | dU/dz |</span>
    <span class="c"># dMdX * M * XYZ = w^2 * | dV/dx | </span>
    <span class="c">#                        | dV/dy |</span>
    <span class="c">#                        \ dV/dz / </span>
    <span class="c">#</span>
    <span class="c"># Where [u,v,w]^T = M * [x,y,z,1]^T</span>
    <span class="c"># </span>
    <span class="n">dMdX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>       <span class="mi">0</span><span class="p">,</span>    <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span>
                     <span class="p">[</span><span class="o">-</span><span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>       <span class="mi">0</span><span class="p">,</span>    <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span>
                     <span class="p">[</span><span class="o">-</span><span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span>       <span class="mi">0</span><span class="p">,</span>    <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]],</span>
                     <span class="p">[</span>      <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>    <span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span>
                     <span class="p">[</span>      <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>    <span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span>
                     <span class="p">[</span>      <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span>    <span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]]])</span>
<span class="c">#    print M, &quot;\n&quot;, np.linalg.det(M[:,:3]), &quot;\n&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">dMdX</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">M</span><span class="p">[:,:</span><span class="mi">3</span><span class="p">]),</span> <span class="n">D</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">D</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">D</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="DLTnormalization"><a class="viewcode-back" href="../../DLTnormalization.html#pyvsim.Utils.DLTnormalization">[docs]</a><span class="k">def</span> <span class="nf">DLTnormalization</span><span class="p">(</span><span class="n">pointslist</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This normalization procedure was suggested in:: &quot;Multiple view geometry in</span>
<span class="sd">    computer vision&quot; by Hartley and Zisserman, and is needed to make the</span>
<span class="sd">    problem of finding the direct linear transform converge better</span>
<span class="sd">    </span>
<span class="sd">    The idea is transforming the set of points so that their average is zero</span>
<span class="sd">    and their distance to the origin is in average sqrt(nb. of coordinates).</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pointslist: numpy.array</span>
<span class="sd">        A matrix with the size (N,C) where N is the number of points and C is </span>
<span class="sd">        the number of coordinates</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    normalized_points: numpy.array</span>
<span class="sd">        A matrix with the same size as the input with the normalized coordinates</span>
<span class="sd">    T: numpy.array</span>
<span class="sd">        A matrix with the form (C+1, C+1) representing the transformation to be</span>
<span class="sd">        used with homogeneous coordinates</span>
<span class="sd">        </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; pointslist = np.array([[0,0],</span>
<span class="sd">    ...                        [0,1],</span>
<span class="sd">    ...                        [1,1],</span>
<span class="sd">    ...                        [1,0]])</span>
<span class="sd">    &gt;&gt;&gt; [normpoints, T] = DLTnormalization(pointslist)</span>
<span class="sd">    &gt;&gt;&gt; (np.mean(normpoints,0) == 0).all()</span>
<span class="sd">    True</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; homogeneouspoints = np.ones((4,3))       #must convert to homog. coords.</span>
<span class="sd">    &gt;&gt;&gt; homogeneouspoints[:,:-1] = normpoints</span>
<span class="sd">    &gt;&gt;&gt; np.dot(np.linalg.inv(T),homogeneouspoints.T).T[:,:-1] #inverse transform</span>
<span class="sd">    array([[ 0.,  0.],</span>
<span class="sd">           [ 0.,  1.],</span>
<span class="sd">           [ 1.,  1.],</span>
<span class="sd">           [ 1.,  0.]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ncoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">pointslist</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
    <span class="n">t</span>           <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">pointslist</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">s</span>           <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">pointslist</span> <span class="o">-</span> <span class="n">t</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">ncoords</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> 
    <span class="n">T</span>           <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">ncoords</span><span class="p">)</span> <span class="o">/</span> <span class="n">s</span> 
    <span class="n">T</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>    <span class="o">=</span> <span class="mi">1</span>
    <span class="n">T</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>   <span class="o">=</span> <span class="o">-</span><span class="n">t</span> <span class="o">/</span> <span class="n">s</span>

    <span class="k">return</span> <span class="p">((</span><span class="n">pointslist</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span><span class="o">/</span><span class="n">s</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
    
    </div>
<div class="viewcode-block" id="pointInHexa"><a class="viewcode-back" href="../../pointInHexa.html#pyvsim.Utils.pointInHexa">[docs]</a><span class="k">def</span> <span class="nf">pointInHexa</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">hexapoints</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Taking a set of points defining a hexahedron in the conventional order,</span>
<span class="sd">    this function tests of the point is inside this hexahedron by:</span>
<span class="sd">   </span>
<span class="sd">    For each face:</span>
<span class="sd">        - calculate normal pointing outwards</span>
<span class="sd">        - verify if point is &quot;behind&quot; the plane defined by the face</span>
<span class="sd">       </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    p : numpy.array (N, 3)</span>
<span class="sd">        List of points to be tested</span>
<span class="sd">    hexapoints : numpy.array (8, 3)</span>
<span class="sd">        List of points defining an hexahedron, must obey the conventional order</span>
<span class="sd">        of defining hexas. Also works in the case hexa has negative volume</span>
<span class="sd">        (this was made especifically for cases when laser sheet is reflected)</span>
<span class="sd">       </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    1 </span>
<span class="sd">        if points lies inside the hexahedron</span>
<span class="sd">    0 </span>
<span class="sd">        otherwise</span>
<span class="sd">        </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; hexapoints = np.array([[0,0,0], </span>
<span class="sd">    ...                        [0,1,0], </span>
<span class="sd">    ...                        [0,1,1], </span>
<span class="sd">    ...                        [0,0,1], </span>
<span class="sd">    ...                        [1,0,0], </span>
<span class="sd">    ...                        [1,1,0], </span>
<span class="sd">    ...                        [1,1,1], </span>
<span class="sd">    ...                        [1,0,1]])</span>
<span class="sd">    &gt;&gt;&gt; p = np.array([[  0,  0,  0], </span>
<span class="sd">    ...               [0.5,0.5,0.5], </span>
<span class="sd">    ...               [  2,  0,  0]])</span>
<span class="sd">    &gt;&gt;&gt; pointInHexa(p, hexapoints)</span>
<span class="sd">    array([ 0.,  1.,  0.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Fix the case of inverted volumes (may happen when mirrors are present)</span>
    <span class="n">v1</span> <span class="o">=</span> <span class="n">hexapoints</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">hexapoints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">v3</span> <span class="o">=</span> <span class="n">hexapoints</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">hexapoints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">v4</span> <span class="o">=</span> <span class="n">hexapoints</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="n">hexapoints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="n">v3</span><span class="p">),</span><span class="n">v4</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">hexatemp</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">8</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
        <span class="n">hexatemp</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">hexapoints</span><span class="p">[</span><span class="mi">4</span><span class="p">:]</span>
        <span class="n">hexatemp</span><span class="p">[</span><span class="mi">4</span><span class="p">:]</span> <span class="o">=</span> <span class="n">hexapoints</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span>
        <span class="n">hexapoints</span>   <span class="o">=</span> <span class="n">hexatemp</span>
   
    <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">truthtable</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">truthtable</span> <span class="o">=</span> <span class="mi">1</span>
              
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>
        <span class="n">vout</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">hexapoints</span><span class="p">[</span><span class="n">HEXA_CONN_PARTIAL</span><span class="p">[</span><span class="n">n</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span> <span class="o">-</span> 
                        <span class="n">hexapoints</span><span class="p">[</span><span class="n">HEXA_CONN_PARTIAL</span><span class="p">[</span><span class="n">n</span><span class="p">,</span><span class="mi">2</span><span class="p">]],</span>
                        <span class="n">hexapoints</span><span class="p">[</span><span class="n">HEXA_CONN_PARTIAL</span><span class="p">[</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span> <span class="o">-</span> 
                        <span class="n">hexapoints</span><span class="p">[</span><span class="n">HEXA_CONN_PARTIAL</span><span class="p">[</span><span class="n">n</span><span class="p">,</span><span class="mi">2</span><span class="p">]])</span>
        
        <span class="n">truthtable</span> <span class="o">=</span> <span class="n">truthtable</span> <span class="o">*</span> \
                    <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&quot;ij,j-&gt;i&quot;</span><span class="p">,</span>
                               <span class="n">p</span> <span class="o">-</span> <span class="n">hexapoints</span><span class="p">[</span><span class="n">HEXA_CONN_PARTIAL</span><span class="p">[</span><span class="n">n</span><span class="p">,</span><span class="mi">2</span><span class="p">]],</span> 
                               <span class="n">vout</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">truthtable</span>                      
                 </div>
<div class="viewcode-block" id="quadInterpolation"><a class="viewcode-back" href="../../quadInterpolation.html#pyvsim.Utils.quadInterpolation">[docs]</a><span class="k">def</span> <span class="nf">quadInterpolation</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">pquad</span><span class="p">,</span><span class="n">values</span><span class="p">):</span> 
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs barycentric interpolation extended to the case of a planar quad</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    p : numpy.array (N, 3)</span>
<span class="sd">    pquad : numpy.array (4, 3)</span>
<span class="sd">    values : numpy.array (4, M)</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : numpy.array (N, M)        </span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; pquad = [[-1,-1,0],</span>
<span class="sd">    ...          [+1,-1,0],</span>
<span class="sd">    ...          [+1,+1,0],</span>
<span class="sd">    ...          [-1,+1,0]]</span>
<span class="sd">    &gt;&gt;&gt; p     = [[0,-1  ,0],</span>
<span class="sd">    ...          [0,-0.5,0],</span>
<span class="sd">    ...          [0,   0,0],</span>
<span class="sd">    ...          [0,  +1,0]]</span>
<span class="sd">    &gt;&gt;&gt; values = [0,0,1,1]</span>
<span class="sd">    &gt;&gt;&gt; quadInterpolation(np.array(p), </span>
<span class="sd">    ...                   np.array(pquad),</span>
<span class="sd">    ...                   np.array(values))</span>
<span class="sd">    array([ 0.  ,  0.25,  0.5 ,  1.  ])</span>
<span class="sd">    </span>
<span class="sd">    For interpolation of vectors</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; values = [[-1,-1,0],</span>
<span class="sd">    ...           [+1,-1,0],</span>
<span class="sd">    ...           [+1,+1,0],</span>
<span class="sd">    ...           [-1,+1,0]]</span>
<span class="sd">    &gt;&gt;&gt; quadInterpolation(np.array(p), </span>
<span class="sd">    ...                   np.array(pquad),</span>
<span class="sd">    ...                   np.array(values))</span>
<span class="sd">    array([[ 0. , -1. ,  0. ],</span>
<span class="sd">           [ 0. , -0.5,  0. ],</span>
<span class="sd">           [ 0. ,  0. ,  0. ],</span>
<span class="sd">           [ 0. ,  1. ,  0. ]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">npts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">npts</span> <span class="o">=</span> <span class="mi">1</span>
        
    <span class="n">Su</span> <span class="o">=</span> <span class="n">triangleArea</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">pquad</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">pquad</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">Sr</span> <span class="o">=</span> <span class="n">triangleArea</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">pquad</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">pquad</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">Sd</span> <span class="o">=</span> <span class="n">triangleArea</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">pquad</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">pquad</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">Sl</span> <span class="o">=</span> <span class="n">triangleArea</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">pquad</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">pquad</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
    <span class="n">den</span> <span class="o">=</span> <span class="p">(</span><span class="n">Su</span> <span class="o">+</span> <span class="n">Sd</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">Sr</span> <span class="o">+</span> <span class="n">Sl</span><span class="p">)</span>
    <span class="n">c1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Sr</span><span class="o">*</span><span class="n">Su</span><span class="o">/</span><span class="n">den</span><span class="p">,(</span><span class="n">npts</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">c2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Sl</span><span class="o">*</span><span class="n">Su</span><span class="o">/</span><span class="n">den</span><span class="p">,(</span><span class="n">npts</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">c3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Sl</span><span class="o">*</span><span class="n">Sd</span><span class="o">/</span><span class="n">den</span><span class="p">,(</span><span class="n">npts</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">c4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Sr</span><span class="o">*</span><span class="n">Sd</span><span class="o">/</span><span class="n">den</span><span class="p">,(</span><span class="n">npts</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    
    <span class="k">return</span> <span class="p">(</span><span class="n">c1</span><span class="o">*</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">c2</span><span class="o">*</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> 
            <span class="n">c3</span><span class="o">*</span><span class="n">values</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">c4</span><span class="o">*</span><span class="n">values</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
           </div>
<div class="viewcode-block" id="Tictoc"><a class="viewcode-back" href="../../Tictoc.html#pyvsim.Utils.Tictoc">[docs]</a><span class="k">class</span> <span class="nc">Tictoc</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Just something simpler than the timeit from Python </span>
<span class="sd">    (and more Matlab-style)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is the class constructor</span>
<span class="sd">        &gt;&gt;&gt; tic = Tictoc()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">begin</span> <span class="o">=</span> <span class="mi">0</span>
        
<div class="viewcode-block" id="Tictoc.tic"><a class="viewcode-back" href="../../Tictoc.html#pyvsim.Utils.Tictoc.tic">[docs]</a>    <span class="k">def</span> <span class="nf">tic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resets the timer, must be used at the before each timed method</span>
<span class="sd">        &gt;&gt;&gt; tic = Tictoc()</span>
<span class="sd">        &gt;&gt;&gt; tic.tic()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">begin</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>
        </div>
<div class="viewcode-block" id="Tictoc.toc"><a class="viewcode-back" href="../../Tictoc.html#pyvsim.Utils.Tictoc.toc">[docs]</a>    <span class="k">def</span> <span class="nf">toc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gives the calculation time or speed, depending if the number of </span>
<span class="sd">        calculations executed from the last reset is provided as the </span>
<span class="sd">        input n.</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; tic = Tictoc()</span>
<span class="sd">        &gt;&gt;&gt; tic.tic()</span>
<span class="sd">        &gt;&gt;&gt; tic.toc() # doctest: +ELLIPSIS</span>
<span class="sd">        Elapsed time: ...</span>
<span class="sd">        ...</span>
<span class="sd">        </span>
<span class="sd">        or</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; tic = Tictoc()</span>
<span class="sd">        &gt;&gt;&gt; tic.tic()</span>
<span class="sd">        &gt;&gt;&gt; tic.toc(10) # doctest: +ELLIPSIS</span>
<span class="sd">        Can execute: ... calculations / second</span>
<span class="sd">        ...</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">begin</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;Elapsed time too short to measure&quot;</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;Elapsed time: </span><span class="si">%f</span><span class="s"> seconds&quot;</span> <span class="o">%</span> <span class="n">t</span>
            <span class="k">return</span> <span class="n">t</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;Can execute: </span><span class="si">%f</span><span class="s"> calculations / second&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="n">t</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">n</span><span class="o">/</span><span class="n">t</span>
           </div></div>
<div class="viewcode-block" id="quadArea"><a class="viewcode-back" href="../../quadArea.html#pyvsim.Utils.quadArea">[docs]</a><span class="k">def</span> <span class="nf">quadArea</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">,</span><span class="n">p3</span><span class="p">,</span><span class="n">p4</span><span class="p">):</span> 
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the area of a quadrilateral defined by its edge points. The </span>
<span class="sd">    following assumptions are made:</span>
<span class="sd">    </span>
<span class="sd">    * All points lie in the same plane        </span>
<span class="sd">    * The quadrilateral is convex</span>
<span class="sd">        </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    p1, p2, p3, p4 : numpy.array (N,3)</span>
<span class="sd">        Points or list of points defining quadrilaterals</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : (N)</span>
<span class="sd">        The area of the quadrilaterals</span>
<span class="sd">        </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; pts    = np.array([[0,0,0], </span>
<span class="sd">    ...                    [0,1,0], </span>
<span class="sd">    ...                    [0,1,1], </span>
<span class="sd">    ...                    [0,0,1]])</span>
<span class="sd">    &gt;&gt;&gt; quadArea(pts[0], pts[1], pts[2], pts[3])</span>
<span class="sd">    1.0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">triangleArea</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">,</span><span class="n">p3</span><span class="p">)</span> <span class="o">+</span> <span class="n">triangleArea</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">p3</span><span class="p">,</span><span class="n">p4</span><span class="p">)</span>
       </div>
<div class="viewcode-block" id="displayProfile"><a class="viewcode-back" href="../../displayProfile.html#pyvsim.Utils.displayProfile">[docs]</a><span class="k">def</span> <span class="nf">displayProfile</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Internal utility to profile a module and display the function calls sorted </span>
<span class="sd">    by the cumulative time taken by each of them. This is a tool for development </span>
<span class="sd">    of the code.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filename : string</span>
<span class="sd">        Name of the module to be profiled. The module must have some executable</span>
<span class="sd">        part.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">pstats</span>
    <span class="kn">import</span> <span class="nn">os</span>
    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&quot;python -m cProfile -o autogenprofile.txt &quot;</span> <span class="o">+</span> <span class="n">filename</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">pstats</span><span class="o">.</span><span class="n">Stats</span><span class="p">(</span><span class="s">&quot;autogenprofile.txt&quot;</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">strip_dirs</span><span class="p">()</span><span class="o">.</span><span class="n">sort_stats</span><span class="p">(</span><span class="s">&#39;cumulative&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">print_stats</span><span class="p">(</span><span class="mi">70</span><span class="p">)</span>
</div>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&quot;Will execute doctest&quot;</span>
    <span class="kn">import</span> <span class="nn">doctest</span>
    <span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">()</span>
    <span class="k">print</span> <span class="s">&quot;If nothing was printed, Utils module is running ok&quot;</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../static/logo.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">pyvsim 1.0 documentation</a> &raquo;</li>
          <li><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Ricardo Entz.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>