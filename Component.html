<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Component &mdash; pyvsim 1.0 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="pyvsim 1.0 documentation" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="index.html">pyvsim 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="component">
<h1>Component<a class="headerlink" href="#component" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="pyvsim.Primitives.Component">
<em class="property">class </em><tt class="descclassname">pyvsim.Primitives.</tt><tt class="descname">Component</tt><a class="reference internal" href="_modules/pyvsim/Primitives.html#Component"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyvsim.Primitives.Component" title="Permalink to this definition">¶</a></dt>
<dd><p>The class component is a representation of elements used in the simulation.</p>
<p>Most of its methods are abstract (throw a NotImplementedError) because the
really useful classes are its derivatives:</p>
<div class="highlight-python"><pre>* :class:`~.Core.Assembly`
* :class:`~.Core.Part`
* :class:`~.Core.Line`</pre>
</div>
<p>However, this class exists to stipulate a common interface for all elements
in simulation, allowing a tree-like nesting of them.</p>
<p>Some attributes (x, y, z, origin, id) are not directly changeable (for 
obvious reasons), only with geometrical transforms, etc, so no setter is
implemented, and if you try to change them, you will get an error.</p>
<p>There is also a implementation of the visitor pattern using the 
<tt class="xref py py-meth docutils literal"><span class="pre">acceptVisitor()</span></tt> method</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="pyvsim.Primitives.Component.alignTo">
<tt class="descname">alignTo</tt><big>(</big><em>x_new</em>, <em>y_new</em>, <em>z_new=None</em>, <em>pivotPoint=None</em>, <em>tol=1e-08</em><big>)</big><a class="reference internal" href="_modules/pyvsim/Primitives.html#Component.alignTo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyvsim.Primitives.Component.alignTo" title="Permalink to this definition">¶</a></dt>
<dd><p>This method allows the alignment of the part to a specific direction
(this is very useful in optical systems definition).</p>
<p>The implementation assumes that at least two <em>orthogonal</em> vectors are
given. There is an assertion to guarantee that.</p>
<p>With the new vector base, a rotation matrix M is calculated, and the
<a class="reference external" href="http://http://en.wikipedia.org/wiki/Rotation_matrix#Conversion_from_and_to_axis-angle">formulation to convert rotation matrix to axis-angle</a>
is used for convenience (as then the method <tt class="xref py py-meth docutils literal"><span class="pre">rotate()</span></tt>
can be directly called).</p>
<p>Obs: No concerns about code efficiency are made, as this method will
probably not be used all the time.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>x_new, [y_new, z_new]</strong> : numpy.array(1,3)</p>
<blockquote>
<div><p>New vectors defining the orientation of the part. The vectors need
NOT to be normalized, but MUST be orthogonal.</p>
<p>Vectors y_new or z_new can be omitted (one at a time) and will be
implicitly calculated</p>
</div></blockquote>
<p><strong>pivotPoint</strong> : numpy.array(1,3)</p>
<blockquote>
<div><p>Point in space around which the rotation occurs. If not given, 
rotates around local origin.</p>
</div></blockquote>
<p><strong>tol</strong> : 1e-8</p>
<blockquote>
<div><p>Many checks are executed in order to guarantee that the new x, y and
z vectors are orthogonal and normalized. This is the tolerance of
these checks.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises :</th><td class="field-body"><p class="first"><strong>AssertionError</strong> :</p>
<blockquote>
<div><p>If the vectors are not perpendicular to the given tolerance (check
is done with a dot product), or if the rotation is performed from
a right-handed coordinate system to a left-handed and vice-versa.</p>
</div></blockquote>
<p><strong>LinAlgError</strong> :</p>
<blockquote class="last">
<div><p>If the calculation has other mathematical problems.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyvsim.Primitives.Component.clearData">
<tt class="descname">clearData</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/pyvsim/Primitives.html#Component.clearData"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyvsim.Primitives.Component.clearData" title="Permalink to this definition">¶</a></dt>
<dd><p>This method must be implemented by each inheriting class. Its function 
is to avoid classes having inconsistent data after a geometric transform.</p>
<p>For example: a camera has a mapnp.ping funcion calculated from raytracing,
then the user moves this camera, making the mapnp.ping invalid.</p>
<p>When a rotation or translation is called the clearData method is also
called, and the class is in charge of cleaning all data that is now
not valid anymore.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyvsim.Primitives.Component.depth">
<tt class="descname">depth</tt><a class="reference internal" href="_modules/pyvsim/Primitives.html#Component.depth"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyvsim.Primitives.Component.depth" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the depth of the component within a tree</p>
</dd></dl>

<dl class="method">
<dt id="pyvsim.Primitives.Component.intersections">
<tt class="descname">intersections</tt><big>(</big><em>p0</em>, <em>p1</em>, <em>tol=1e-08</em><big>)</big><a class="reference internal" href="_modules/pyvsim/Primitives.html#Component.intersections"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyvsim.Primitives.Component.intersections" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a method used specifically for ray tracing. The method returns 
data about the first intersection between line segments and the 
polygons defined in the Component. The implementation of the
intersection is given by the inheriting classes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>p0, p1 - numpy.array (N x 3)</strong> :</p>
<blockquote>
<div><p>Coordinates defining N segments by 2 points (each p0, p1 pair), 
which will be tested for intersection with the polygons defined in 
the structure.</p>
</div></blockquote>
<p><strong>tol - double</strong> :</p>
<blockquote>
<div><p>Tolerance used in the criteria for intersection (see documentation
of each implementation)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>None</strong> :</p>
<blockquote>
<div><p>If no intersections are found.</p>
</div></blockquote>
<p><strong>Otherwise returns a list with::</strong> :</p>
<p><strong>lineParameter</strong> :</p>
<blockquote>
<div><p>This is used to indicate how far the intersection point is from the
segment starting point, if 0, the intersection is at p0 and if 1, 
the intersection is at p1</p>
<p><em>Iff</em> the parameter is &gt; 1 (999), no intersection was found</p>
</div></blockquote>
<p><strong>intersectionCoordinates</strong> :</p>
<blockquote>
<div><p>This is where the intersections are found</p>
</div></blockquote>
<p><strong>triangleIndexes</strong> :</p>
<blockquote>
<div><p>This is the index of the triangle where the intersection was found.
If no intersection found, will return 0, <em>but attention</em>, the only
way to guarantee that no intersection was found is when the 
lineParameter is zero.</p>
</div></blockquote>
<p><strong>normals</strong> :</p>
<blockquote>
<div><p>The normal vector at the intersection point (if the surface is
defined with normals at vertices, interpolation is performed).</p>
</div></blockquote>
<p><strong>part</strong> :</p>
<blockquote class="last">
<div><p>A list with references to this object. This is, in this case, 
redundant, but that makes the function signature uniform with the
<cite>:class:~Core.Assembly</cite></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyvsim.Primitives.Component.rotate">
<tt class="descname">rotate</tt><big>(</big><em>angle</em>, <em>axis</em>, <em>pivotPoint=None</em><big>)</big><a class="reference internal" href="_modules/pyvsim/Primitives.html#Component.rotate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyvsim.Primitives.Component.rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>This method should be used when there is a change in the component
position. This method operates only with the origin and the x, y and z
vectors. It delegates the responsibility to the inheriting class by 
means of the <tt class="xref py py-meth docutils literal"><span class="pre">rotateImplementation()</span></tt> method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>angle</strong> :</p>
<blockquote>
<div><p>Angle : scalar (in radians)</p>
</div></blockquote>
<p><strong>axis</strong> : numpy.array (1 x 3)</p>
<blockquote>
<div><p>Vector around which the rotation occurs.</p>
</div></blockquote>
<p><strong>pivotPoint</strong> : numpy.array (1 x 3)</p>
<blockquote class="last">
<div><p>Point in space around which the rotation occurs. If not given, 
rotates around origin.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyvsim.Primitives.Component.rotateImplementation">
<tt class="descname">rotateImplementation</tt><big>(</big><em>angle</em>, <em>axis</em>, <em>pivotPoint</em><big>)</big><a class="reference internal" href="_modules/pyvsim/Primitives.html#Component.rotateImplementation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyvsim.Primitives.Component.rotateImplementation" title="Permalink to this definition">¶</a></dt>
<dd><p>This method must be implemented by the interested inheriting class in
case a rotation affects its internals.</p>
<p>For example: a class with a vector of points P will probably need to
update them accordingly using the following code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">P</span> <span class="o">=</span> <span class="n">Utils</span><span class="o">.</span><span class="n">rotatePoints</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">angle</span><span class="p">,</span><span class="n">axis</span><span class="p">,</span><span class="n">pivotPoint</span><span class="p">)</span>
</pre></div>
</div>
<p>This is a way of implementing the <cite>Chain of Responsibility 
&lt;http://http://en.wikipedia.org/wiki/Chain-of-responsibility_pattern&gt;</cite> 
pattern, so that these geometrical operations are executed recursively.</p>
<p><em>This is a protected method, do not use it unless you are inheriting
from this class!</em></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>angle</strong> :</p>
<blockquote>
<div><p>Angle : scalar (in radians)</p>
</div></blockquote>
<p><strong>axis</strong> : numpy.array (1 x 3)</p>
<blockquote>
<div><p>Vector around which the rotation occurs.</p>
</div></blockquote>
<p><strong>pivotPoint</strong> : numpy.array (1 x 3)</p>
<blockquote>
<div><p>Point in space around which the rotation occurs. If not given, 
rotates around origin.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises :</th><td class="field-body"><p class="first last"><strong>NotImplementedError</strong> :</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyvsim.Primitives.Component.translate">
<tt class="descname">translate</tt><big>(</big><em>vector</em><big>)</big><a class="reference internal" href="_modules/pyvsim/Primitives.html#Component.translate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyvsim.Primitives.Component.translate" title="Permalink to this definition">¶</a></dt>
<dd><p>This method should be used when there is a change in the component
position. This method operates only with the origin position, and
delegates the responsibility to the inheriting class by means of the
<tt class="xref py py-meth docutils literal"><span class="pre">translateImplementation()</span></tt> method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>vector</strong> : numpy.array (1 x 3)</p>
<blockquote class="last">
<div><p>Vector to translate the component. An array with x, y and z 
coordinates</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyvsim.Primitives.Component.translateImplementation">
<tt class="descname">translateImplementation</tt><big>(</big><em>vector</em><big>)</big><a class="reference internal" href="_modules/pyvsim/Primitives.html#Component.translateImplementation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyvsim.Primitives.Component.translateImplementation" title="Permalink to this definition">¶</a></dt>
<dd><p>This method must be implemented by the interested inheriting class in
case a translation affects its internals.</p>
<p>For example: a class with a vector of points P will probably need to
update that to P+vector</p>
<p>This is a way of implementing the <cite>Chain of Responsibility 
&lt;http://http://en.wikipedia.org/wiki/Chain-of-responsibility_pattern&gt;</cite> 
pattern, so that these geometrical operations are executed recursively.</p>
<p><em>This is a protected method, do not use it unless you are inheriting
from this class!</em></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>vector</strong> : numpy.array (1 x 3)</p>
<blockquote>
<div><p>Vector to translate the component. An array with x, y and z 
coordinates</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises :</th><td class="field-body"><p class="first last"><strong>NotImplementedError</strong> :</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/logo.png" alt="Logo"/>
            </a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/Component.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<ul class="this-page-menu">
  <li><a href="/scipy/docs/scipy-docs/Component.rst">Edit page</a></li>
</ul>

<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="index.html">pyvsim 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Ricardo Entz.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2b1.
    </div>
  </body>
</html>